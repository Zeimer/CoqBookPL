Najnowszy rewolucyjny pomysł: użyć jsCoq do zrobienia interaktywnej książki, która wyglądałaby jakoś tak: https://x80.org/rhino-coq/v8.10/
Biedniejszy pomysł: zrobić zwijane/rozwijane dowody i paragrafy.

Najnowszy plan refaktoringu:

Wstęp i inne tego typu pierdoły

Logika: Podstawy
  Konstruktywny rachunek zdań
  Konstruktywny rachunek kwantyfikatorów
  Klasyczny rachunek kwantyfikatorów. Zrobić tak żeby można było pisać "Classically $ coś tam".
  Przedstawić obie logiki jako użyteczne - pluralizm logiczny.
  Paradoks pijoka, czyli esencja klasyczności.
  Paradoks golibrody, czyli związki logiki z rzeczywistością.
  Paradoks pieniądza i kebaba, czyli o zasobach.
  Na końcu dać podrozdział o kombinatorach taktyk (albo i nie).
  Napisać coś o nazwach zmiennych związanych
  Przedstawić jakieś bardziej ludzkie definicje predykatu i relacji (tzn. bierze coś i zwraca zdanie).
  Zadania:
    wyrzucić zadania mącące (mieszające typy i zdania)
    dodać zadanie dotyczące czytania twierdzeń i dowodów
    dodać zadania dotyczące czytania formuł (precedencja etc.)
    modelowanie różnych sytuacji za pomocą zdań i predykatów. Rozwiązywanie zagadek logicznych.
    dodać jakieś wyjaśnienia do ćwiczeń
    więcej zadań z exists
    zadania z klasycznego rachunku kwantyfikatorów

Podstawy teorii typów:
  Przypomnienie dedukcji naturalnej z rozdziału 1.
  Curry-Howard
  Pięć rodzajów reguł
  HoTT-bookowa teoria typów: pusty, unit, bool, nat, produkt, suma, funkcje, produkt zależy, suma zależna
  Przemieścić z R1 podrozdziały "Typy i termy" oraz "Typy a zbiory".

Ogólnie: Rozdział o logice powinien zawierać omówienie dedukcji naturalnej. Dzięki temu można wprowadzić korespondencję CH, a z niej wywieść pięć rodzajów reguł i opisać teorię typów w stylu HoTTbooka.

Typy induktywne
  Enumeracje, czyli sumy nazwane.
    Kontent: ewaluacja (to co obecnie jest przy opisie typu [bool]).
    Przykładowe typy: kierunki, kolory RGB, dni tygodnia, uprawnienia dostępu (R, W, RW, etc.), pusty, unit
    Ćwiczenia: logika boolowska. Dokładnie wszystko opisać i powiązać z logiką klasyczną
  Parametry.
    Kontent: polimorfizm.
    Przykładowe typy: prod, sum.
    Ćwiczenia: typ option.
  Konstruktory rekurencyjne.
    Kontent: rekursja.
    Przykładowe typy: nat
    Ćwiczenia: arytmetyka Peano.
  Indukcja wzajemna.
  Indeksy. Byle porządnie.
  Indukcja-indukcja.
  Indukcja-rekursja.
  Indukcja-indukcja-rekursja.
  Typy ilorazowe, wyższe typy indutkywne.
  Zadania z definiowania induktywnych typów i predykatów
  W międzyczasie: omówić ścisłą pozytywność
Inne
  dodać podrozdział o typach induktywnych z nieskończoną ilością argumentów rekurencyjnych (A -> T)

Typy i funkcje
  Aksjomat ekstensjonalności
  Lewa i prawa skracalność
  Lewa i prawa odwrotność
  Izomorfizm
  Injekcja, bijekcja, surjekcja
  Inwolucja i idempotencja
  Przemycać jak najwięcej teorii kategorii

Typy i relacje
  Obecna wersja (X5) wymaga tutaj klas.

Taktyki do redukcji i obliczeń
  Posłużyć się następującym systemem nazewniczo-klasyfikacyjnym.
  Dla każdej literki są trzy relacje: redukcja, ekspansja i konwersja
  (a może powinna być jeszcze redukcja w wielu krokach?).
  Bazą jest redukcja, która ma jakąś swoją definicję, pisana jest
  a -> b. Relacja ekspansji a <- b zdefiniowana jest jako b -> a, zaś
  relacja konwersji to domknięcie równoważnościowe relacji redukcji.
  W takim układzie redukcja w wielu krokach to domknięcie zwrotno-
  przechodnie relacji redukcji. Podobnie dla ekspansji w wielu krokach.

  Mamy następujące relacje redukcji:
    alfa (zmiana nazwy jednej zmiennej związanej)
    beta (podstawienie argumentu za parametr formalny w jednym miejscu)
    delta (odwinięcie jednej definicji) — uwaga: to w sumie nie jest
      relacja, tylko rodzina relacji parametryzowana/indeksowana nazwami,
      które chcemy odwinąć
    eta - unikalność dla funkcji, rekordów etc.
    iota (wykonanie jednego dopasowania do wzorca)
    zeta (redukcja pojedynczego [let]a)

  Odpowiadające taktyki:
    alfa — brak
    beta — cbn/cbv beta
    delta — cbn/cbv delta, unfold, fold
    eta — brak
    iota — cbn/cbv iota
    zeta — cbn/cbv zeta
    ogólna redukcja: cbn, cbv, simpl,
    konwersja: change

  Omówić następujące taktyki (w kolejności):
    [pattern] (beta ekspansja)
    [unfold], [fold] (delta redukcja/ekspansja)
    [change] (konwertowalność)
    [cbn]
    [compute], [vm_compute], [native_compute]
    [cbv], [lazy]
    [red]
    [simpl]
    [hnf]

  Omówić postacie normalne (o ile gdzieś można znaleźć jakiś ich opis).
  Ogólniej: wstawić jakąś zajawkę wcześnie i bardziej szczegółowy opis
  po rozdziale o relacjach. Trzeba by też opisać rachunek lambda.

Rekordy i klasy
  Typy skończone
  Enumerowanie
  Rozstrzygalność i typ [reflect]
  Rozstrzygalna równość
  Rozstrzygalność
  Rodzaje rekordów: induktywne, koinduktywne, primitive projections

Matematyka
  o typach ilorazowych
  setoidy
  teoria porządków
  monoidy i teoria grup

Definiowanie funkcji
  rekursja "prymitywna" (jak w Agdzie)
  rekursja strukturalna
  rekursja polimorficzna
  rekursja "monotoniczna" (fix w fiksie)
  rekursja paliwowa
  rekursja dobrze ufundowana
  metoda Bove-Capretta z trickiem wycinającym indukcję-rekursję
  rekursja przez iterację
  rekursja wydmuszkowa (Coq'Art)
  teoria dziedzin (computation, CPDT)
  comp (CPDT)
  koindukcja (thunk, CPDT)

Typy koinduktywne
  Rekordy, parametry i korekursja.
  Kontent: liczby konaturalne, strumienie, kolisty, kodrzewa.

Bonusowy rozdział teoretyczny: kodowanie Churcha dla typów induktywnych i koinduktywnych

Ltac
  być może przenieść tu z rozdziału 1 fragment o kombinatorach taktyk

Spis taktyk
  nieopisane taktyki: [induction], [inversion], [destruct]
  przerobić "drobne taktyki" na "taktyki do zarządzania kontekstem"
  przenieść opis taktyki [pattern] (i odpowiadające zadanie) do części o taktykach dla redukcji

Reflekcja, metapoziom, quote (którego oczywiście w Coqu nie ma, a jak) i inne takie duperele
  Po co reflekcja?
  Semantyka vs składnia

Listy
  napisać wstępy do poszczególnych funkcji
  Dodać przykładowe wywołania funkcji do ćwiczeń.
  ogólnie trzeba będzie zrobić gruntowny refaktoring list według planu zawartego w List_sig.v
  opisz niestandardowe reguły indukcyjne dla list (najlepiej przed funkcją [intersperse])
  przenieś [intersperse] na sam koniec funkcji i dorzuć jeszcze kilka dziwnych (z niestandardowym kształtem indukcji)
  opisz zwijanie i rozwijanie ([fold] i [foldl])
  opisz sumy prefiksowe ([scanr] i [scanl])
  zrób osobno: funkcje na listach dla typów mających jakieś specjalne rzeczy (np. rozstrzygalną równość)
  Opisać relacje prefix/infix/suffix/interfix dla list jako jakotakie ćwiczenie
  niedokończone funkcje (do niedawna oznaczone jako TODO):
    isZero (przenieść do rozdziału o arytmetyce)
    isEmpty
    snoc
    bind
    iterate i iter (join, bind)
    insert (join, bind, iterate, init)
    remove
    take (join, bind, last_take, take_remove),
    drop (join, bind, remove)
    iterate (od removeFirst wzwyż)
    removeFirst (removeFirst_zip)
    findIndex (init, tail)
    filter (tail, init)
    findIndices (join, bind, takeWhile, dropWhile)
    pmap (iterate, nth, last, tail i init, take i drop, takedrop, zip,
          unzip, zipWith, unzipWith, removeFirst i removeLast, findIndex,
          findIndices)
    intersperse (init, insert, remove, drop, zip, zipWith, unzip)
    groupBy
    Rep (join, nth)
    AtLeast (nth, head, last, init, tail)
    Exactly (join, nth, head, tail, init, last, zip)
    AtMost
    popracować nad [findIndices] (i to w dwóch wersjach - być może jest to dobry pretekst dla wprowadzenia stylu programowania z akumulatorem?)

Złożoność:
  Napisać coś o rekursji ogonowej i opisać poświęcone jej techniki dowodzenia.

Monady i efekty jako sposoby bycia
- [Id] nie reprezentuje żadnego efektu. Wartości typu [Id A] są w ten
  sposób, że po prostu są.
- [option] reprezentuje częściowość. Wartości typu [option A] są w ten
  sposób, że albo są, albo ich nie ma
- [sum E] reprezentuje możliwość wystąpienia błędu. Wartości typu
  [sum E A] są w ten sposób, że albo są poprawne, albo ich nie ma, gdyż
  wystąpił błąd typu [E].
- [list] reprezentuje niedeterminizm (uporządkowany). Wartości typu
  [list A] są w ten sposób, że może ich być wiele lub może ich nie być
  wcale i są w sposób uporządkowany.
- [State S] reprezentuje stan. Wartości typu [State S A] są w ten
  sposób, że są i mają pamięć, tzn. mogą się zmieniać w zależności
  od stanu.
- [Reader R] reprezentuje możliwość odczytania konfiguracji.
- [Writer W] reprezentuje możliwość zapisywania logów.
- [Future] reprezentuję asynchroniczność. Wartości typu [Future A]
  są w ten sposób, że albo są teraz, albo będą później.
- [STM] reprezentuje transakcje. Wartościu typu [STM A] są w ten
  sposób, że są w jednym kawałku, są transakcjami.
- [SQL] reprezentuje operacje bazodanowe. Wartości typu [SQL A] są
  w ten sposób, że albo po prostu są, albo są w bazie danych.

Kontynuacje i kontrola

Logika-Aksjomaty
  Ekstensjonalność: funext, propext, uniwalencja
  Relewancja: proof irrelevance, K
  
Logika: Uniwersa
  Przemieścić z R2 podrozdziały o sortach i o hierarchii uniwersów. Najlepiej gdzieś na sam koniec
Logika: równość - przeanalizować alternatywne definicje, opowiedzieć skąd się biorą dowody równości

Teoria Kategorii

Inne
  definiowanie przez dowód
  o silnych specyfikacjach
  być może przesunąć Empty_set i unit za Enumeracje, a prod i sum za Właściwości konstruktorów. Wcisnąć tu ukrytą teorię kategorii.

Ogólne plany na rozdziały X:
  typ bool (powinien być osobny rozdział). Inne:
    boolowska logika ternarna, być może jako tour de force dla automatyzacji? albo test kreatywności
  typ option (być może przy okazji funktory?) Stąd zadania dla [head], [last], [tail] i [init]
  wcisnąć tu rozdział o produktach, sumach i funkcjach?
  arytmetyka i typ [nat]. Reszta arytmetyki:
    liczby dodatnie (positive)
    binarne liczby naturalne
    liczby całkowite
    liczby wymierne
    systemy liczbowe
  listy list i ich różne pochodne:
    listy niepuste nel
    wektory zależne vec
    wektory podtypowe (jak w ssreflekcie)
  drzewa ukorzenione:
    binarne węzłowe BTree
    binarne liściowe (wisienki)
    ogólne węzłowe Tree
    ogólne liściowe RoseTree
    jakieś inne? (węzłowe niepuste)
  algorytmy
    drzewa wyszukiwań
    sterty
    sortowanie

Sugestie i problemy z koła:
  nie trzeba specjalizować hipotezy, żeby przepisać
  być może coś więcej o równości (i jej alternatywnej definicji?)
  napisać bardziej wprost o deklarowaniu hipotez
  ulepszyć ściągę z taktykami i komendami
