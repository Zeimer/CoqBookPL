<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link href="coqdoc.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="jquery-1.8.3.js"></script>
<script type="text/javascript" src="main.js"></script>
<script type="text/javascript" src="MyStyles.js"></script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-88023543-1', 'auto');
  ga('send', 'pageview');

</script>
</head>
<h1 class="libtitle">X: Chilowo śmietnik</h1>

<div class="code">
</div>

<div class="doc">

<div class="paragraph"> </div>

 Jak sama nazwa wskazuje, niniejszy tymczasowy rozdział robi za śmietnik,
    czy też raczej zbiornik retencyjny, do którego wylewa się mój strumień
    świadomości niepasujący gdzie indziej. 
<div class="paragraph"> </div>

<a name="lab522"></a><h1 class="section">Parametryczność</h1>

<div class="paragraph"> </div>

 UWAGA TODO: ten podrozdział zawiera do pewnego stopnia kłamstwa (tzn.
    dość uproszczony punkt widzenia). 
<div class="paragraph"> </div>

 Niech <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Set</span></span>. Zadajmy sobie następujące pytanie: ile jest funkcji
    typu <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">B</span></span>? Żeby ułatwić sobie zadanie, ograniczmy się jedynie do
    typów, które mają skończoną ilość elementów.

<div class="paragraph"> </div>

    Nietrudno przekonać się, że ich ilość to |B|^|A|, gdzie ^ oznacza
    potęgowanie, zaś |T| to ilość elementów typu <span class="inlinecode"><span class="id" title="var">T</span></span> (ta notacja nie ma
    nic wspólnego z Coqiem — zaadaptowałem ją z teorii zbiorów jedynie
    na potrzeby tego podrozdziału).

<div class="paragraph"> </div>

    Udowodnić ten fakt możesz (choć póki co nie w Coqu) posługując się
    indukcją po ilości elementów typu <span class="inlinecode"><span class="id" title="var">A</span></span>. Jeżeli <span class="inlinecode"><span class="id" title="var">A</span></span> jest pusty, to
    jest tylko jedna taka funkcja, o czym przekonałeś się już podczas
    ćwiczeń w podrozdziale o typie <span class="inlinecode"><span class="id" title="var">Empty_set</span></span>. 
<div class="paragraph"> </div>

<a name="lab523"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 Udowodnij (nieformalnie, na papierze), że w powyższym akapicie nie
    okłamałem cię. 
<div class="paragraph"> </div>

<a name="lab524"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 Zdefiniuj wszystkie możliwe funkcje typu <span class="inlinecode"><span class="id" title="var">unit</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">unit</span></span>, <span class="inlinecode"><span class="id" title="var">unit</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span></span>
    i <span class="inlinecode"><span class="id" title="var">bool</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span></span>. 
<div class="paragraph"> </div>

 Postawmy sobie teraz trudniejsze pytanie: ile jest funkcji typu
    <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Set</span>,</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">A</span></span>? W udzieleniu odpowiedzi pomoże nam
    parametryczność — jedna z właściwości Coqowego polimorfizmu.

<div class="paragraph"> </div>

    Stwierdzenie, że polimorfizm w Coqu jest parametryczny, oznacza, że
    funkcja biorąca typ jako jeden z argumentów działa w taki sam sposób
    niezależnie od tego, jaki typ przekażemy jej jako argument.

<div class="paragraph"> </div>

    Konsekwencją tego jest, że funkcje polimorficzne nie wiedzą (i nie
    mogą wiedzieć), na wartościach jakiego typu operują. Wobec tego
    elementem typu <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Set</span>,</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">A</span></span> nie może być funkcja, która
    np. dla typu <span class="inlinecode"><span class="id" title="var">nat</span></span> stale zwraca <span class="inlinecode">42</span>, a dla innych typów po prostu
    zwraca przekazany jej argument.

<div class="paragraph"> </div>

    Stąd konkludujemy, że typ <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Set</span>,</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">A</span></span> ma tylko jeden
    element, a mianowicie polimorficzną funkcję identycznościową. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">id'</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">A</span> : <span class="id" title="keyword">Set</span>, <span class="id" title="var">A</span> -&gt; <span class="id" title="var">A</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">fun</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Set</span>) (<span class="id" title="var">x</span> : <span class="id" title="var">A</span>) =&gt; <span class="id" title="var">x</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab525"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 Zdefiniuj wszystkie elementy następujących typów lub udowodnij, że
    istnienie choć jednego elementu prowadzi do sprzeczności:
<ul class="doclist">
<li> <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Set</span>,</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">A</span></span>

</li>
<li> <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Set</span>,</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">A</span></span>

</li>
<li> <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Set</span>,</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">B</span></span>

</li>
<li> <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Set</span>,</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">A</span></span>

</li>
<li> <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Set</span>,</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">B</span></span>

</li>
<li> <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Set</span>,</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">*</span> <span class="inlinecode"><span class="id" title="var">B</span></span>

</li>
<li> <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Set</span>,</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">sum</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode"><span class="id" title="var">B</span></span>

</li>
<li> <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode"><span class="id" title="var">C</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Set</span>,</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">C</span></span>

</li>
<li> <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Set</span>,</span> <span class="inlinecode"><span class="id" title="var">option</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">A</span></span>

</li>
<li> <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Set</span>,</span> <span class="inlinecode"><span class="id" title="var">list</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">A</span></span> 
</li>
</ul>

</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
TODO: tu opisać kłamstwo 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">path</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">x</span> : <span class="id" title="var">A</span>) : <span class="id" title="var">A</span> -&gt; <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">idpath</span> : <span class="id" title="var">path</span> <span class="id" title="var">x</span> <span class="id" title="var">x</span>.<br/>

<br/>
<span class="id" title="var">Arguments</span> <span class="id" title="var">idpath</span> {<span class="id" title="var">A</span>} <span class="id" title="var">_</span>.<br/>

<br/>
<span class="id" title="keyword">Axiom</span> <span class="id" title="var">LEM</span> : <span class="id" title="keyword">forall</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>), <span class="id" title="var">A</span> + (<span class="id" title="var">A</span> -&gt; <span class="id" title="var">Empty_set</span>).<br/>

<br/>
<span class="id" title="keyword">Open</span> <span class="id" title="keyword">Scope</span> <span class="id" title="var">type_scope</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">bad'</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) :<br/>
&nbsp;&nbsp;{<span class="id" title="var">f</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">A</span> &amp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(@<span class="id" title="var">path</span> <span class="id" title="keyword">Type</span> <span class="id" title="var">bool</span> <span class="id" title="var">A</span> * <span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> : <span class="id" title="var">A</span>, <span class="id" title="var">f</span> <span class="id" title="var">x</span> &lt;&gt; <span class="id" title="var">x</span>) +<br/>
&nbsp;&nbsp;&nbsp;&nbsp;((@<span class="id" title="var">path</span> <span class="id" title="keyword">Type</span> <span class="id" title="var">bool</span> <span class="id" title="var">A</span> -&gt; <span class="id" title="var">Empty_set</span>) * <span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> : <span class="id" title="var">A</span>, <span class="id" title="var">f</span> <span class="id" title="var">x</span> = <span class="id" title="var">x</span>)}.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> (<span class="id" title="var">LEM</span> (@<span class="id" title="var">path</span> <span class="id" title="keyword">Type</span> <span class="id" title="var">bool</span> <span class="id" title="var">A</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">p</span>. <span class="id" title="var">esplit</span> <span class="id" title="keyword">with</span> <span class="id" title="var">negb</span>. <span class="id" title="tactic">left</span>. <span class="id" title="tactic">split</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exact</span> (@<span class="id" title="var">idpath</span> <span class="id" title="keyword">Type</span> <span class="id" title="var">bool</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">x</span>; <span class="id" title="var">cbn</span>; <span class="id" title="tactic">inversion</span> 1.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">esplit</span> <span class="id" title="keyword">with</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> : <span class="id" title="var">A</span> =&gt; <span class="id" title="var">x</span>). <span class="id" title="tactic">right</span>. <span class="id" title="tactic">split</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">bad</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">A</span> := <span class="id" title="var">projT1</span> (<span class="id" title="var">bad'</span> <span class="id" title="var">A</span>).<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">bad_is_bad</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">b</span> : <span class="id" title="var">bool</span>, <span class="id" title="var">bad</span> <span class="id" title="var">bool</span> <span class="id" title="var">b</span> &lt;&gt; <span class="id" title="var">b</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="tactic">unfold</span> <span class="id" title="var">bad</span>. <span class="id" title="tactic">destruct</span> <span class="id" title="var">bad'</span>. <span class="id" title="var">cbn</span>. <span class="id" title="tactic">destruct</span> <span class="id" title="var">s</span> <span class="id" title="keyword">as</span> [[<span class="id" title="var">p</span> <span class="id" title="var">H</span>] | [<span class="id" title="var">p</span> <span class="id" title="var">H</span>]].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> (<span class="id" title="var">p</span> (<span class="id" title="var">idpath</span> <span class="id" title="var">_</span>)).<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">bad_ist_gut</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">x</span> : <span class="id" title="var">A</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(@<span class="id" title="var">path</span> <span class="id" title="keyword">Type</span> <span class="id" title="var">bool</span> <span class="id" title="var">A</span> -&gt; <span class="id" title="var">Empty_set</span>) -&gt; <span class="id" title="var">bad</span> <span class="id" title="var">A</span> <span class="id" title="var">x</span> = <span class="id" title="var">x</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">bad</span>. <span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">x</span> <span class="id" title="var">p</span>. <span class="id" title="tactic">destruct</span> <span class="id" title="var">bad'</span> <span class="id" title="keyword">as</span> [<span class="id" title="var">f</span> [[<span class="id" title="var">q</span> <span class="id" title="var">H</span>] | [<span class="id" title="var">q</span> <span class="id" title="var">H</span>]]]; <span class="id" title="var">cbn</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> (<span class="id" title="var">p</span> <span class="id" title="var">q</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">H</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab526"></a><h1 class="section">Rozstrzygalność</h1>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">excluded_middle</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">P</span> : <span class="id" title="keyword">Prop</span>, <span class="id" title="var">P</span> \/ ~ <span class="id" title="var">P</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intro</span>. <span class="id" title="tactic">left</span>.<br/>
<span class="id" title="keyword">Restart</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intro</span>. <span class="id" title="tactic">right</span>. <span class="id" title="tactic">intro</span>.<br/>
<span class="id" title="keyword">Abort</span>.<br/>

<br/>
</div>

<div class="doc">
Próba udowodnienia tego twierdzenia pokazuje nam zasadniczą różnicę
    między logiką konstruktywną, która jest domyślną logiką Coqa, oraz
    logiką klasyczną, najpowszechniej znanym i używanym rodzajem logiki.

<div class="paragraph"> </div>

    Każde zdanie jest, w pewnym "filozoficznym" sensie, prawdziwe lub
    fałszywe i to właśnie powyższe zdanie oznacza w logice klasycznej.
    Logika konstruktywna jednak, jak już wiemy, nie jest logiką prawdy,
    lecz logiką udowadnialności i ma swoją interpretację obliczeniową.
    Powyższe zdanie w logice konstruktywnej oznacza: program komputerowy
    <span class="inlinecode"><span class="id" title="var">exluded_middle</span></span> rozstrzyga, czy dowolne zdanie jest prawdziwe, czy
    fałszywe.

<div class="paragraph"> </div>

    Skonstruowanie programu o takim typie jest w ogólności niemożliwe,
    gdyż dysponujemy zbyt małą ilością informacji: nie wiemy czym jest
    zdanie <span class="inlinecode"><span class="id" title="var">P</span></span>, a nie posiadamy żadnego ogólnego sposobu dowodzenia lub
    obalania zdań o nieznanej nam postaci. Nie możemy np. użyć indukcji,
    gdyż nie wiemy, czy zdanie <span class="inlinecode"><span class="id" title="var">P</span></span> zostało zdefiniowane induktywnie, czy
    też nie. W Coqu jedynym sposobem uzyskania termu o typie <span class="inlinecode"><span class="id" title="keyword">forall</span></span>
    <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Prop</span>,</span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">\/</span> <span class="inlinecode">~</span> <span class="inlinecode"><span class="id" title="var">P</span></span> jest przyjęcie go jako aksjomat. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">True_dec</span> : <span class="id" title="var">True</span> \/ ~ <span class="id" title="var">True</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">left</span>. <span class="id" title="tactic">trivial</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Powyższe dywagacje nie przeszkadzają nam jednak w udowadnianiu,
    że reguła wyłączonego środka zachodzi dla pewnych konkretnych
    zdań. Zdanie takie będziemy nazywać zdaniami rozstrzygalnymi
    (ang. decidable). O pozostałych zdaniach będziemy mówić, że są 
    nierozstrzygalne (ang. undecidable). Ponieważ w Coqu wszystkie
    funkcje są rekurencyjne, a dowody to programy, to możemy powyższą
    definicję rozumieć tak: zdanie jest rozstrzygalne, jeżeli istnieje
    funkcja rekurencyjna o przeciwdzidzinie <span class="inlinecode"><span class="id" title="var">bool</span></span>, która sprawdza, czy
    jest ono prawdziwe, czy fałszywe.

<div class="paragraph"> </div>

    Przykładami zdań, predykatów czy problemów rozstrzygalnych są:
<ul class="doclist">
<li> sprawdzanie, czy lista jest niepusta

</li>
<li> sprawdzanie, czy liczba naturalna jest parzysta

</li>
<li> sprawdzanie, czy dwie liczby naturalne są równe 
</li>
</ul>

<div class="paragraph"> </div>

 Przykładem problemów nierozstrzygalnych są:
<ul class="doclist">
<li> dla funkcji <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">g</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> sprawdzenie, czy
      <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span>,</span> <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">g</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> — jest to w ogólności niemożliwe,
      gdyż wymaga wykonania nieskończonej ilości porównań (co nie
      znaczy, że nie da się rozwiązać tego problemu dla niektórych
      funkcji)

</li>
<li> sprawdzenie, czy słowo o nieskończonej długości jest palindromem 
</li>
</ul>

<div class="paragraph"> </div>

<a name="lab527"></a><h4 class="section">Ćwiczenie</h4>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">eq_nat_dec</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">n</span> = <span class="id" title="var">m</span> \/ ~ <span class="id" title="var">n</span> = <span class="id" title="var">m</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab528"></a><h2 class="section">Techniczne apekty rozstrzygalności</h2>

<div class="paragraph"> </div>

 Podsumowując powyższe rozważania, moglibyśmy stwierdzić: zdanie <span class="inlinecode"><span class="id" title="var">P</span></span> jest
    rozstrzygalne, jeżeli istnieje term typu <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">\/</span> <span class="inlinecode">~</span> <span class="inlinecode"><span class="id" title="var">P</span></span>. Stwierdzenie takie
    nie zamyka jednak sprawy, gdyż bywa czasem mocno bezużyteczne.

<div class="paragraph"> </div>

    Żeby to zobrazować, spróbujmy użyć twierdzenia <span class="inlinecode"><span class="id" title="var">eq_nat_dec</span></span> do napisania
    funkcji, która sprawdza, czy liczna naturalna <span class="inlinecode"><span class="id" title="var">n</span></span> występuje na liście
    liczb naturalnych <span class="inlinecode"><span class="id" title="var">l</span></span>: 
</div>
<div class="code">

<br/>
<span class="id" title="var">Fail</span> <span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">inb_nat</span> (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) (<span class="id" title="var">l</span> : <span class="id" title="var">list</span> <span class="id" title="var">nat</span>) : <span class="id" title="var">bool</span> :=<br/>
<span class="id" title="keyword">match</span> <span class="id" title="var">l</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">nil</span> =&gt; <span class="id" title="var">false</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">cons</span> <span class="id" title="var">h</span> <span class="id" title="var">t</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">eq_nat_dec</span> <span class="id" title="var">n</span> <span class="id" title="var">h</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">or_introl</span> <span class="id" title="var">_</span> =&gt; <span class="id" title="var">true</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">_</span> =&gt; <span class="id" title="var">inb_nat</span> <span class="id" title="var">n</span> <span class="id" title="var">t</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span><br/>
<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
Coq nie akceptuje powyższego kodu, racząc nas informacją o błędzie: 
</div>
<div class="code">

<br/>
<span class="comment">(*&nbsp;Error:<br/>
&nbsp;&nbsp;&nbsp;Incorrect&nbsp;elimination&nbsp;of&nbsp;"eq_nat_dec&nbsp;n&nbsp;h0"&nbsp;in&nbsp;the&nbsp;inductive&nbsp;type&nbsp;"or":<br/>
&nbsp;&nbsp;&nbsp;the&nbsp;return&nbsp;type&nbsp;has&nbsp;sort&nbsp;"Set"&nbsp;while&nbsp;it&nbsp;should&nbsp;be&nbsp;"Prop".<br/>
&nbsp;&nbsp;&nbsp;Elimination&nbsp;of&nbsp;an&nbsp;inductive&nbsp;object&nbsp;of&nbsp;sort&nbsp;Prop<br/>
&nbsp;&nbsp;&nbsp;is&nbsp;not&nbsp;allowed&nbsp;on&nbsp;a&nbsp;predicate&nbsp;in&nbsp;sort&nbsp;Set<br/>
&nbsp;&nbsp;&nbsp;because&nbsp;proofs&nbsp;can&nbsp;be&nbsp;eliminated&nbsp;only&nbsp;to&nbsp;build&nbsp;proofs.&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Nasza porażka wynika z faktu, że do zdefiniowania funkcji, która
    jest programem (jej dziedzina i przeciwdziedzina są sortu <span class="inlinecode"><span class="id" title="keyword">Set</span></span>)
    próbowaliśmy użyć termu <span class="inlinecode"><span class="id" title="var">eq_nat_dec</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode"><span class="id" title="var">h</span></span>, który jest dowodem
    (konkluzją <span class="inlinecode"><span class="id" title="var">eq_nat_dec</span></span> jest równość, która jest sortu <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>).

<div class="paragraph"> </div>

    Mimo korespondencji Curry'ego-Howarda, która odpowiada za olbrzymie
    podobieństwo specyfikacji i zdań, programów i dowodów, sortu <span class="inlinecode"><span class="id" title="keyword">Set</span></span>
    i sortu <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>, są one rozróżniane i niesie to za sobą konsekwencje:
    podczas gdy programów możemy używać wszędzie, dowodów możemy używać
    jedynie do konstruowania innych dowodów.

<div class="paragraph"> </div>

    Praktycznie oznacza to, że mimo iż równość liczb naturalnych jest
    rozstrzygalna, pisząc program nie mamy możliwości jej rozstrzygania
    za pomocą <span class="inlinecode"><span class="id" title="var">eq_nat_dec</span></span>. To właśnie miałem na myśli pisząc, że termy
    typu <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">\/</span> <span class="inlinecode">~</span> <span class="inlinecode"><span class="id" title="var">P</span></span> są mocno bezużyteczne.

<div class="paragraph"> </div>

    Uszy do góry: nie wszystko stracone! Jest to tylko drobna przeszkoda,
    którą bardzo łatwo ominąć: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">sumbool</span> (<span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Prop</span>) : <span class="id" title="keyword">Set</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="tactic">left</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">sumbool</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="tactic">right</span> : <span class="id" title="var">B</span> -&gt; <span class="id" title="var">sumbool</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span>.<br/>

<br/>
</div>

<div class="doc">
Typ <span class="inlinecode"><span class="id" title="var">sumbool</span></span> jest niemal dokładną kopią <span class="inlinecode"><span class="id" title="var">or</span></span>, jednak nie żyje on
    w <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>, lecz w <span class="inlinecode"><span class="id" title="keyword">Set</span></span>. Ta drobna sztuczka, że termy typu
    <span class="inlinecode"><span class="id" title="var">sumbool</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode"><span class="id" title="var">B</span></span> formalnie są programami, mimo że ich naturalna
    interpretacja jest taka sama jak <span class="inlinecode"><span class="id" title="var">or</span></span>, a więc jako dowodu
    dysjunkcji. 
<div class="paragraph"> </div>

<a name="lab529"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 Udowodnij twierdzenie <span class="inlinecode"><span class="id" title="var">eq_nat_dec'</span></span> o rozstrzygalności <span class="inlinecode">=</span> na
    liczbach naturalnych. Użyj typu <span class="inlinecode"><span class="id" title="var">sumbool</span></span>. Następnie napisz
    funkcję <span class="inlinecode"><span class="id" title="var">inb_nat</span></span>, która sprawdza, czy liczba naturalna <span class="inlinecode"><span class="id" title="var">n</span></span>
    jest obecna na liście <span class="inlinecode"><span class="id" title="var">l</span></span>. 
<div class="paragraph"> </div>

<a name="lab530"></a><h1 class="section">Typy hybrydowe</h1>

<div class="paragraph"> </div>

 Ostatnim z typów istotnych z punktu widzenia silnych specyfikacji
    jest typ o wdzięcznej nazwie <span class="inlinecode"><span class="id" title="var">sumor</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <span class="id" title="var">sumor</span>.<br/>

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">sumor</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">B</span> : <span class="id" title="keyword">Prop</span>) : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">inleft</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">sumor</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">inright</span> : <span class="id" title="var">B</span> -&gt; <span class="id" title="var">sumor</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span>.<br/>

<br/>
</div>

<div class="doc">
Jak sama nazwa wskazuje, <span class="inlinecode"><span class="id" title="var">sumor</span></span> jest hybrydą sumy rozłącznej <span class="inlinecode"><span class="id" title="var">sum</span></span>
    oraz dysjunkcji <span class="inlinecode"><span class="id" title="var">or</span></span>. Możemy go interpretować jako typ, którego
    elementami są elementy <span class="inlinecode"><span class="id" title="var">A</span></span> albo wymówki w stylu "nie mam elementu <span class="inlinecode"><span class="id" title="var">A</span></span>,
    ponieważ zachodzi zdanie <span class="inlinecode"><span class="id" title="var">B</span></span>". <span class="inlinecode"><span class="id" title="var">B</span></span> nie zależy od <span class="inlinecode"><span class="id" title="var">A</span></span>, a więc jest to
    zwykła suma (a nie suma zależna, czyli uogólnienie produktu). <span class="inlinecode"><span class="id" title="var">sumor</span></span>
    żyje w <span class="inlinecode"><span class="id" title="keyword">Type</span></span>, a więc jest to specyfikacja i liczy się konkretna
    postać jego termów, a nie jedynie fakt ich istnienia. 
<div class="paragraph"> </div>

<a name="lab531"></a><h4 class="section">Ćwiczenie (<span class="inlinecode"><span class="id" title="var">pred'</span></span>)</h4>

<div class="paragraph"> </div>

 Zdefiniuj funkcję <span class="inlinecode"><span class="id" title="var">pred'</span></span>, która przypisuje liczbie naturalnej jej
    poprzednik. Poprzednikiem <span class="inlinecode">0</span> nie powinno być <span class="inlinecode">0</span>. Mogą przydać ci
    się typ <span class="inlinecode"><span class="id" title="var">sumor</span></span> oraz sposób definiowania za pomocą taktyk, omówiony
    w podrozdziale dotyczącym sum zależnych. 
</div>
<div class="code">

<br/>

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">sumor</span>.<br/>
</div>
