<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link href="coqdoc.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="jquery-1.8.3.js"></script>
<script type="text/javascript" src="main.js"></script>
<script type="text/javascript" src="MyStyles.js"></script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-88023543-1', 'auto');
  ga('send', 'pageview');

</script>
</head>
<h1 class="libtitle">D2ipół</h1>

<div class="code">
</div>

<div class="doc">
W tym rozdziale będą różne formy indukcji/rekursji, których chwilowo nie
    chcę wstawiać do głównego tekstu rozdziałów D1 i D2, bo tam nie pasują.
    Prędzej czy później zostaną one z tymi rozdział zintegrowane (albo i nie -
    nie mamy pańskiego płaszcza i co nam pan zrobi?). 
<div class="paragraph"> </div>

<a name="lab235"></a><h1 class="section">Rekursja prymitywna (TODO)</h1>

</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
<a name="lab236"></a><h1 class="section">Rekursja zagnieżdżona</h1>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <span class="id" title="var">X3</span>.<br/>

<br/>
</div>

<div class="doc">
Czas na omówienie pewnej ciekawej, ale średnio użytecznej formy rekursji
    (z pamięci nie jestem w stanie przytoczyć więcej niż dwóch sztampowych
    przykładów jej użycia), a jest nią rekursja zagnieżdżona (zwana też
    czasem rekursją monotoniczną - kwestię najlepszej nazwy dla tego czegoś
    i jej uzasadnienia omówimy potem).

<div class="paragraph"> </div>

    Cóż to za zwierzątko, rekursja zagnieżdżona? Żeby się tego dowiedzieć,
    rzućmy najpierw okiem na przykład jakiejś funkcji, której definicja
    wymaga użycia rekursji zagnieżdżonej. 
</div>
<div class="code">

<br/>
<span class="id" title="var">Fail</span> <span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">ack</span> (<span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>) : <span class="id" title="var">nat</span> :=<br/>
<span class="id" title="keyword">match</span> <span class="id" title="var">n</span>, <span class="id" title="var">m</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| 0, <span class="id" title="var">m</span> =&gt; <span class="id" title="var">S</span> <span class="id" title="var">m</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">S</span> <span class="id" title="var">n'</span>, 0 =&gt; <span class="id" title="var">ack</span> <span class="id" title="var">n'</span> 1<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">S</span> <span class="id" title="var">n'</span>, <span class="id" title="var">S</span> <span class="id" title="var">m'</span> =&gt; <span class="id" title="var">ack</span> <span class="id" title="var">n'</span> (<span class="id" title="var">ack</span> (<span class="id" title="var">S</span> <span class="id" title="var">n'</span>) <span class="id" title="var">m'</span>)<br/>
<span class="id" title="keyword">end</span>.<br/>

<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;The&nbsp;command&nbsp;has&nbsp;indeed&nbsp;failed&nbsp;with&nbsp;message:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Cannot&nbsp;guess&nbsp;decreasing&nbsp;argument&nbsp;of&nbsp;fix.&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Powyższa funkcja zwana jest funkcją Ackermanna, gdyż wymyślił ją...
    zgadnij kto. Jest ona całkiem sławna, choć z zupełnie innych powodów
    niż te, dla których my się jej przyglądamy. Nie oblicza ona niczego
    specjalnie użytecznego - jej wynikami są po prostu bardzo duże liczby.
    Jeżeli nie wierzysz, spróbuj policzyć ręcznie <span class="inlinecode"><span class="id" title="var">ack</span></span> <span class="inlinecode">4</span> <span class="inlinecode">2</span> - zdziwisz się.

<div class="paragraph"> </div>

    Jak widać, Coq nie akceptuje powyższej definicji. Winny temu jest rzecz
    jasna kształt rekursji. Dla <span class="inlinecode"><span class="id" title="var">n</span></span> równego <span class="inlinecode">0</span> zwracamy <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span>, co jest ok.
    Dla <span class="inlinecode"><span class="id" title="var">n</span></span> postaci <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n'</span></span> i <span class="inlinecode"><span class="id" title="var">m</span></span> równego <span class="inlinecode">0</span> robimy wywołanie rekurencyjne
    na <span class="inlinecode"><span class="id" title="var">n'</span></span> i <span class="inlinecode">1</span>, co również jest ok. Jednak jeżeli <span class="inlinecode"><span class="id" title="var">n</span></span> i <span class="inlinecode"><span class="id" title="var">m</span></span> odpowednio
    są postaci <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n'</span></span> i <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">m'</span></span>, to robimy wywołanie rekurencyjne postaci
    <span class="inlinecode"><span class="id" title="var">ack</span></span> <span class="inlinecode"><span class="id" title="var">n'</span></span> <span class="inlinecode">(<span class="id" title="var">ack</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n'</span>)</span> <span class="inlinecode"><span class="id" title="var">m'</span>)</span>. W wewnętrznym wywołaniu rekurencyjnym pierwszy
    argument jest taki sam jak w obecnym wywołaniu, a zatem pierwszy argument
    nie może być argumentem głównym. Gdyby argumentem głównym był drugi
    argument, to jest tym bardziej źle, gdyż w zewnętrznym wywołaniu
    rekurencyjnym nie jest nim <span class="inlinecode"><span class="id" title="var">m'</span></span>, lecz <span class="inlinecode"><span class="id" title="var">ack</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n'</span>)</span> <span class="inlinecode"><span class="id" title="var">m'</span></span>. Nie ma się więc
    co dziwić, że Coq nie może zgadnąć, który argument ma być argumentem
    głównym.

<div class="paragraph"> </div>

    Mimo, że Coq nie akceptuje tej definicji, to wydaje się ona być całkiem
    spoko. Żaden z argumentów nie może wprawdzie posłużyć nam za argument
    główny, ale jeżeli rozważymy ich zachowanie jako całość, to okazuje się,
    że w każdym wywołaniu rekurencyjnym mamy dwie możliwości:
<ul class="doclist">
<li> albo pierwszy argument się zmniejsza

</li>
<li> albo pierwszy argument się nie zmienia, ale drugi argument się
      zmniejsza

</li>
</ul>

<div class="paragraph"> </div>

    Możemy z tego wywnioskować, że jeżeli wywołamy <span class="inlinecode"><span class="id" title="var">ack</span></span> na argumentach
    <span class="inlinecode"><span class="id" title="var">n</span></span> i <span class="inlinecode"><span class="id" title="var">m</span></span>, to w ogólności najpierw <span class="inlinecode"><span class="id" title="var">m</span></span> będzie się zmniejszał, ale
    ponieważ musi kiedyś spaść do zera, to wtedy <span class="inlinecode"><span class="id" title="var">n</span></span> będzie musiał się
    zmniejszyć. Oczywiście wtedy w kolejnym wywołaniu zaczynamy znowu z
    jakimś <span class="inlinecode"><span class="id" title="var">m</span></span>, które potem się zmniejsza, aż w końcu znowu zmniejszy
    się <span class="inlinecode"><span class="id" title="var">n</span></span> i tak dalej, aż do chwili, gdy <span class="inlinecode"><span class="id" title="var">n</span></span> spadnie do zera. Wtedy
    rekursja musi się skończyć.

<div class="paragraph"> </div>

    Jednym z typowych zastosowań rekursji zagnieżdżonej jest radzenie
    sobie z takimi właśnie przypadkami, w których mamy ciąg argumentów
    i pierwszy maleje, lub pierwszy stoi w miejscu a drugi maleje i tak
    dalej. Z tego też powodu rekursja zagnieżdżona bywa czasem nazywana
    rekursją monotoniczną.

<div class="paragraph"> </div>

    Czas zobaczyć, jak techniki tej można użyć do zdefiniowania funkcji
    Ackermanna. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">ack</span> (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) : <span class="id" title="var">nat</span> -&gt; <span class="id" title="var">nat</span> :=<br/>
<span class="id" title="keyword">match</span> <span class="id" title="var">n</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| 0 =&gt; <span class="id" title="var">S</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">S</span> <span class="id" title="var">n'</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">fix</span> <span class="id" title="var">ack'</span> (<span class="id" title="var">m</span> : <span class="id" title="var">nat</span>) : <span class="id" title="var">nat</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">m</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 0 =&gt; <span class="id" title="var">ack</span> <span class="id" title="var">n'</span> 1<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">S</span> <span class="id" title="var">m'</span> =&gt; <span class="id" title="var">ack</span> <span class="id" title="var">n'</span> (<span class="id" title="var">ack'</span> <span class="id" title="var">m'</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span><br/>
<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
Zauważmy przede wszystkim, że nieco zmienia się wygląd typu naszej
    funkcji. Jest on wprawdzie dokładnie taki sam (<span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">nat</span></span>),
    ale zapisujemy go inaczej. Robimy to by podkreslić, że wynikiem <span class="inlinecode"><span class="id" title="var">ack</span></span>
    jest funkcja. W przypadku gdy <span class="inlinecode"><span class="id" title="var">n</span></span> jest postaci <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n'</span></span> zdefiniowana
    jest ona za pomocą <span class="inlinecode"><span class="id" title="keyword">fix</span></span>a tak, jak wyglądają dwie ostatnie klauzule
    dopasowania z oryginalnej definicji, ale z wywołaniem <span class="inlinecode"><span class="id" title="var">ack</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n'</span>)</span> <span class="inlinecode"><span class="id" title="var">m'</span></span>
    zastąpionym przez <span class="inlinecode"><span class="id" title="var">ack'</span></span> <span class="inlinecode"><span class="id" title="var">m'</span></span>. Tak więc funkcja <span class="inlinecode"><span class="id" title="var">ack'</span></span> reprezentuje
    częściową aplikację <span class="inlinecode"><span class="id" title="var">ack</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span>.

<div class="paragraph"> </div>

    Co w powyższej definicji sprawia, że jest to przykład rekursji
    zagnieżdżonej? 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Print</span> <span class="id" title="var">ack</span>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;ack&nbsp;=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fix&nbsp;ack&nbsp;(n&nbsp;:&nbsp;nat)&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;nat&nbsp;:=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;match&nbsp;n&nbsp;with<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;0&nbsp;=&gt;&nbsp;S<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;S&nbsp;n'&nbsp;=&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fix&nbsp;ack'&nbsp;(m&nbsp;:&nbsp;nat)&nbsp;:&nbsp;nat&nbsp;:=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;match&nbsp;m&nbsp;with<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;0&nbsp;=&gt;&nbsp;ack&nbsp;n'&nbsp;1<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;S&nbsp;m'&nbsp;=&gt;&nbsp;ack&nbsp;n'&nbsp;(ack'&nbsp;m')<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;nat&nbsp;-&gt;&nbsp;nat<br/>
*)</span><br/>

<br/>
</div>

<div class="doc">
Tym, którzy nie pamiętają, przypominam, że komenda <span class="inlinecode"><span class="id" title="keyword">Fixpoint</span></span> jest
    jedynie cukrem syntaktycznym na wyrażenie <span class="inlinecode"><span class="id" title="keyword">fix</span></span>, które służy do
    definiowania funkcji rekurencyjnych. <span class="inlinecode"><span class="id" title="keyword">fix</span></span> działa podobnie jak <span class="inlinecode"><span class="id" title="keyword">fun</span></span>,
    ale pozwala dodatkowo nadać definiowanej przez siebie funkcji nazwę,
    dzięki czemu możemy robić wywołania rekurencyjne. Tak więc komendę
    <span class="inlinecode"><span class="id" title="keyword">Fixpoint</span></span> możemy zastąpić komendą <span class="inlinecode"><span class="id" title="keyword">Definition</span></span> i wyrażeniem <span class="inlinecode"><span class="id" title="keyword">fix</span></span>.

<div class="paragraph"> </div>

    Czym więc jest rekursja zagnieżdżona? Z rekursją zagnieżdżoną mamy
    do czynienia, gdy przez rekursję (czyli za pomocą <span class="inlinecode"><span class="id" title="keyword">fix</span></span>a) definiujemy
    funkcję, która zwraca inną funkcję, i ta zwracana funkcja także jest
    zdefiniowana przez rekursję (czyli za pomocą <span class="inlinecode"><span class="id" title="keyword">fix</span></span>a). Oczywiście to
    tylko pierwszy krok - wynikowa funkcja również może zwracać funkcję,
    która jest zdefiniowana przez rekursję i tak dalej.

<div class="paragraph"> </div>

    Widać zatem jak na dłoni, że <span class="inlinecode"><span class="id" title="var">ack</span></span> jest zdefiniowane za pomocą rekursji
    zagnieżdżonej, gdyż w powyższej definicji za pomocą <span class="inlinecode"><span class="id" title="keyword">fix</span></span>a definiujemy
    funkcję, która dla <span class="inlinecode"><span class="id" title="var">n</span></span> postaci <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n'</span></span> zwraca funkcję zdefiniowaną za
    pomocą kolejnego <span class="inlinecode"><span class="id" title="keyword">fix</span></span>a. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">plus</span> : <span class="id" title="var">nat</span> -&gt; <span class="id" title="var">nat</span> -&gt; <span class="id" title="var">nat</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">fix</span> <span class="id" title="var">f</span> (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) : <span class="id" title="var">nat</span> -&gt; <span class="id" title="var">nat</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">n</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 0 =&gt; <span class="id" title="keyword">fun</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span> =&gt; <span class="id" title="var">m</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">S</span> <span class="id" title="var">n'</span> =&gt; <span class="id" title="keyword">fun</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span> =&gt; <span class="id" title="var">S</span> (<span class="id" title="var">f</span> <span class="id" title="var">n'</span> <span class="id" title="var">m</span>)<br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
Dla balansu, powyższa definicja funkcji <span class="inlinecode"><span class="id" title="var">plus</span></span> nie jest przykładem
    rekursji zagnieżdżonej, gdyż o ile definiujemy <span class="inlinecode"><span class="id" title="var">plus</span></span> przez rekursję
    i zwracamy funkcję z <span class="inlinecode"><span class="id" title="var">nat</span></span> w <span class="inlinecode"><span class="id" title="var">nat</span></span>, to funkcja ta zdefiniowana jest
    za pomocą <span class="inlinecode"><span class="id" title="keyword">fun</span></span>, a więc nie jest rekurencyjna.

<div class="paragraph"> </div>

    Podsumowując: rekursja jest zagnieżdżona, gdy w definicji funkcji
    pojawiają się co najmniej dwa wystąpienia <span class="inlinecode"><span class="id" title="keyword">fix</span></span>, jedno wewnątrz
    drugiego. Stąd też pochodzi nazwa "rekursja zagnieżdżona": jeden
    <span class="inlinecode"><span class="id" title="keyword">fix</span></span> jest zagnieżdżony wewnątrz drugiego.

<div class="paragraph"> </div>

    Dobra, dość tych teoretycznych bajdurzeń. Zobaczmy, jak możemy udowodnić
    coś ciekawego na temat funkcji <span class="inlinecode"><span class="id" title="var">ack</span></span>. 
</div>
<div class="code">

<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">ack_eq</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">ack</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> =<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">n</span>, <span class="id" title="var">m</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 0, <span class="id" title="var">_</span> =&gt; <span class="id" title="var">S</span> <span class="id" title="var">m</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">S</span> <span class="id" title="var">n'</span>, 0 =&gt; <span class="id" title="var">ack</span> <span class="id" title="var">n'</span> 1<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">S</span> <span class="id" title="var">n'</span>, <span class="id" title="var">S</span> <span class="id" title="var">m'</span> =&gt; <span class="id" title="var">ack</span> <span class="id" title="var">n'</span> (<span class="id" title="var">ack</span> (<span class="id" title="var">S</span> <span class="id" title="var">n'</span>) <span class="id" title="var">m'</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">n</span>, <span class="id" title="var">m</span>; <span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Pierwszą i najważniejszą (bo najbardziej przydatną) rzeczą, której nam
    trzeba, jest równanie rekurencyjne, które charakteryzuje funkcję <span class="inlinecode"><span class="id" title="var">ack</span></span>
    tak, jak nieudanie próbowaliśmy ją początkowo zdefiniować. Jest ono
    niesamowicie użyteczne, gdyż użycie taktyki <span class="inlinecode"><span class="id" title="var">cbn</span></span> bardzo często będzie
    się kończyć odwinięciem definicji <span class="inlinecode"><span class="id" title="var">ack</span></span>, co skutkuje zaśmieceniem naszego
    drogocennego ekranu i utrudnia rozeznanie w stanie dowodu. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">ack_big</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">m</span> &lt; <span class="id" title="var">ack</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">n</span> <span class="id" title="keyword">as</span> [| <span class="id" title="var">n'</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">cbn</span>. <span class="id" title="tactic">intro</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">le_n</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">m</span> <span class="id" title="keyword">as</span> [| <span class="id" title="var">m'</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">cbn</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">lt_trans</span> <span class="id" title="keyword">with</span> 1.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">le_n</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">IHn'</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">ack_eq</span>. <span class="id" title="tactic">specialize</span> (<span class="id" title="var">IHn'</span> (<span class="id" title="var">ack</span> (<span class="id" title="var">S</span> <span class="id" title="var">n'</span>) <span class="id" title="var">m'</span>)). <span class="id" title="tactic">omega</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Tadam... w sumie, to zaskoczenia nie ma. Reguła jest prosta: jeżeli
    funkcja jest zdefiniowana przez rekursję zagnieżdżoną, to dowody
    będą szły przez zagnieżdżone użycia indukcji.

<div class="paragraph"> </div>

    W powyższym dowodzie zaczynamy od indukcji po <span class="inlinecode"><span class="id" title="var">n</span></span>, bo jest to argument
    głównym funkcji <span class="inlinecode"><span class="id" title="var">ack</span></span>. Pierwszy przypadek jest prosty - trzeba obliczyć
    i użyć zwrotność porządku. Drugi przypadek jest bardziej wymagający.
    Zauważ, że nie używamy tutaj taktyki <span class="inlinecode"><span class="id" title="var">cbn</span></span>, ponieważ skończyłoby się to
    odwinięciem definicji <span class="inlinecode"><span class="id" title="var">ack</span></span> do nieprzyjemnej postaci.

<div class="paragraph"> </div>

    W drugim przypadku używamy indukcji po <span class="inlinecode"><span class="id" title="var">m</span></span>, gdyż jest ono argumentem
    głównym wewnętrznej funkcji <span class="inlinecode"><span class="id" title="var">ack'</span></span>. W pierwszym przypadku znów jest
    w miarę łatwo: zero jest mniejsze niż jeden, zaś jeden jest mniejsze
    od <span class="inlinecode"><span class="id" title="var">ack</span></span> <span class="inlinecode"><span class="id" title="var">n'</span></span> <span class="inlinecode">1</span> na mocy hipotezy indukcyjnej (ale tej pochodzącej od
    indukcji po <span class="inlinecode"><span class="id" title="var">n</span></span>, a nie po <span class="inlinecode"><span class="id" title="var">m</span></span>!).

<div class="paragraph"> </div>

    W ostatnim przypadku również nie używamy <span class="inlinecode"><span class="id" title="var">cbn</span></span> - efekt byłby podobny
    jak poprzednio, czyli zaśmiecenie ekranu długaśnym <span class="inlinecode"><span class="id" title="keyword">fix</span></span>em. Zamiast
    tego korzystamy z równania rekurencyjnego, które elegancko przepisuje
    nam <span class="inlinecode"><span class="id" title="var">ack</span></span> do pożądanej postaci. Dzięki odrobinie spostrzegawczości
    możemy zauważyć, że po odpowiednim zainstancjowaniu hipotezy indukcyjnej
    (tej pochodzącej z indukcji po <span class="inlinecode"><span class="id" title="var">n</span></span>, a nie po <span class="inlinecode"><span class="id" title="var">m</span></span> - tej nie możemy wcale
    zainstancjować!) dostajemy szlaczek nierówności
    <span class="inlinecode"><span class="id" title="var">m'</span></span> <span class="inlinecode">&lt;</span> <span class="inlinecode"><span class="id" title="var">ack</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n'</span>)</span> <span class="inlinecode"><span class="id" title="var">m'</span></span> <span class="inlinecode">&lt;</span> <span class="inlinecode"><span class="id" title="var">ack</span></span> <span class="inlinecode"><span class="id" title="var">n'</span></span> <span class="inlinecode">(<span class="id" title="var">ack</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n'</span>)</span> <span class="inlinecode"><span class="id" title="var">m'</span>)</span>, z którego nasz celu wynika
    bez problemu - na szczęście nie musimy tego arytmetycznego rozumowania
    robić ręcznie, bo bozia dała nam taktykę <span class="inlinecode"><span class="id" title="tactic">omega</span></span>, która potrafi zrobić
    to sama. 
<div class="paragraph"> </div>

<a name="lab237"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 Udowodnij, że funkcja <span class="inlinecode"><span class="id" title="var">ack</span></span> zachowuje porządek <span class="inlinecode">&lt;=</span>, tzn. na większym
    lub równym argumencie (czy to pierwszym, czy drugim, czy obydwu) jej
    wynik również jest większy lub równy.

<div class="paragraph"> </div>

    Uwaga: to ćwiczenie jest trudne technicznie, ale nie konceptualnie. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">ack_monotone</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n1</span> <span class="id" title="var">n2</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">n1</span> &lt;= <span class="id" title="var">n2</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">m1</span> <span class="id" title="var">m2</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">m1</span> &lt;= <span class="id" title="var">m2</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">ack</span> <span class="id" title="var">n1</span> <span class="id" title="var">m1</span> &lt;= <span class="id" title="var">ack</span> <span class="id" title="var">n2</span> <span class="id" title="var">m2</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab238"></a><h4 class="section">Ćwiczenie</h4>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <span class="id" title="var">Arith</span>.<br/>

<br/>
</div>

<div class="doc">
Zdefiniuj funkcję <span class="inlinecode"><span class="id" title="var">merge</span></span> o typie
    <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode">(<span class="id" title="var">A</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Type</span>)</span> <span class="inlinecode">(<span class="id" title="var">cmp</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span>),</span> <span class="inlinecode"><span class="id" title="var">list</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">list</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">list</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span>,
    która scala dwie listy posortowane według porządku wyznaczanego przez
    <span class="inlinecode"><span class="id" title="var">cmp</span></span> w jedną posortowaną listę. Jeżeli któraś z list posortowana nie
    jest, wynik może być dowolny.

<div class="paragraph"> </div>

    Wskazówka: zgadnij, dlaczego to ćwiczenie pojawia się w podrozdziale o
    rekursji zagnieżdżonej. 
</div>
<div class="code">

<br/>

<br/>
<span class="id" title="keyword">Compute</span> <span class="id" title="var">merge</span> <span class="id" title="var">leb</span> [1; 4; 6; 9] [2; 3; 5; 8].<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;=&nbsp;<span class="inlinecode">[1;</span> <span class="inlinecode">2;</span> <span class="inlinecode">3;</span> <span class="inlinecode">4;</span> <span class="inlinecode">5;</span> <span class="inlinecode">6;</span> <span class="inlinecode">8;</span> <span class="inlinecode">9]</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;list&nbsp;nat&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Obie listy są posortowane według <span class="inlinecode"><span class="id" title="var">leb</span></span>, więc wynik też jest. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Compute</span> <span class="id" title="var">merge</span> <span class="id" title="var">leb</span> [5; 3; 1] [4; 9].<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;=&nbsp;<span class="inlinecode">[4;</span> <span class="inlinecode">5;</span> <span class="inlinecode">3;</span> <span class="inlinecode">1;</span> <span class="inlinecode">9]</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;list&nbsp;nat&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Pierwsza lista nie jest posortowana według <span class="inlinecode"><span class="id" title="var">leb</span></span>, więc wynik jest
    z dupy. 
<div class="paragraph"> </div>

<a name="lab239"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 Skoro już udało ci się zdefiniować <span class="inlinecode"><span class="id" title="var">merge</span></span>, to udowodnij jeszcze parę
    lematów, cobyś nie miał za dużo wolnego czasu. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">merge_eq</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} {<span class="id" title="var">cmp</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">A</span> -&gt; <span class="id" title="var">bool</span>} {<span class="id" title="var">l1</span> <span class="id" title="var">l2</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span>},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">merge</span> <span class="id" title="var">cmp</span> <span class="id" title="var">l1</span> <span class="id" title="var">l2</span> =<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">l1</span>, <span class="id" title="var">l2</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| [], <span class="id" title="var">_</span> =&gt; <span class="id" title="var">l2</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">_</span>, [] =&gt; <span class="id" title="var">l1</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">h1</span> :: <span class="id" title="var">t1</span>, <span class="id" title="var">h2</span> :: <span class="id" title="var">t2</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">if</span> <span class="id" title="var">cmp</span> <span class="id" title="var">h1</span> <span class="id" title="var">h2</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">then</span> <span class="id" title="var">h1</span> :: <span class="id" title="var">merge</span> <span class="id" title="var">cmp</span> <span class="id" title="var">t1</span> <span class="id" title="var">l2</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">else</span> <span class="id" title="var">h2</span> :: <span class="id" title="var">merge</span> <span class="id" title="var">cmp</span> <span class="id" title="var">l1</span> <span class="id" title="var">t2</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">merge_nil_l</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} {<span class="id" title="var">cmp</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">A</span> -&gt; <span class="id" title="var">bool</span>} {<span class="id" title="var">l</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span>},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">merge</span> <span class="id" title="var">cmp</span> [] <span class="id" title="var">l</span> = <span class="id" title="var">l</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">merge_nil_r</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} {<span class="id" title="var">cmp</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">A</span> -&gt; <span class="id" title="var">bool</span>} {<span class="id" title="var">l</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span>},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">merge</span> <span class="id" title="var">cmp</span> <span class="id" title="var">l</span> [] = <span class="id" title="var">l</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">merge_length</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} {<span class="id" title="var">f</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">A</span> -&gt; <span class="id" title="var">bool</span>} {<span class="id" title="var">l1</span> <span class="id" title="var">l2</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span>},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">length</span> (<span class="id" title="var">merge</span> <span class="id" title="var">f</span> <span class="id" title="var">l1</span> <span class="id" title="var">l2</span>) = <span class="id" title="var">length</span> <span class="id" title="var">l1</span> + <span class="id" title="var">length</span> <span class="id" title="var">l2</span>.<br/>

<br/>

<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">merge_map</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> {<span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>} {<span class="id" title="var">cmp</span> : <span class="id" title="var">B</span> -&gt; <span class="id" title="var">B</span> -&gt; <span class="id" title="var">bool</span>} {<span class="id" title="var">f</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">B</span>} {<span class="id" title="var">l1</span> <span class="id" title="var">l2</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span>},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">merge</span> <span class="id" title="var">cmp</span> (<span class="id" title="var">map</span> <span class="id" title="var">f</span> <span class="id" title="var">l1</span>) (<span class="id" title="var">map</span> <span class="id" title="var">f</span> <span class="id" title="var">l2</span>) =<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">map</span> <span class="id" title="var">f</span> (<span class="id" title="var">merge</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> : <span class="id" title="var">A</span> =&gt; <span class="id" title="var">cmp</span> (<span class="id" title="var">f</span> <span class="id" title="var">x</span>) (<span class="id" title="var">f</span> <span class="id" title="var">y</span>)) <span class="id" title="var">l1</span> <span class="id" title="var">l2</span>).<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">merge_replicate</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} {<span class="id" title="var">cmp</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">A</span> -&gt; <span class="id" title="var">bool</span>} {<span class="id" title="var">x</span> <span class="id" title="var">y</span> : <span class="id" title="var">A</span>} {<span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">merge</span> <span class="id" title="var">cmp</span> (<span class="id" title="var">replicate</span> <span class="id" title="var">n</span> <span class="id" title="var">x</span>) (<span class="id" title="var">replicate</span> <span class="id" title="var">m</span> <span class="id" title="var">y</span>) =<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">if</span> <span class="id" title="var">cmp</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">then</span> <span class="id" title="var">replicate</span> <span class="id" title="var">n</span> <span class="id" title="var">x</span> ++ <span class="id" title="var">replicate</span> <span class="id" title="var">m</span> <span class="id" title="var">y</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">else</span> <span class="id" title="var">replicate</span> <span class="id" title="var">m</span> <span class="id" title="var">y</span> ++ <span class="id" title="var">replicate</span> <span class="id" title="var">n</span> <span class="id" title="var">x</span>.<br/>

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">ins</span><br/>
&nbsp;&nbsp;{<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">cmp</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">A</span> -&gt; <span class="id" title="var">bool</span>) (<span class="id" title="var">x</span> : <span class="id" title="var">A</span>) (<span class="id" title="var">l</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span>) : <span class="id" title="var">list</span> <span class="id" title="var">A</span> :=<br/>
<span class="id" title="keyword">match</span> <span class="id" title="var">l</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| [] =&gt; [<span class="id" title="var">x</span>]<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">h</span> :: <span class="id" title="var">t</span> =&gt; <span class="id" title="keyword">if</span> <span class="id" title="var">cmp</span> <span class="id" title="var">x</span> <span class="id" title="var">h</span> <span class="id" title="keyword">then</span> <span class="id" title="var">x</span> :: <span class="id" title="var">h</span> :: <span class="id" title="var">t</span> <span class="id" title="keyword">else</span> <span class="id" title="var">h</span> :: <span class="id" title="var">ins</span> <span class="id" title="var">cmp</span> <span class="id" title="var">x</span> <span class="id" title="var">t</span><br/>
<span class="id" title="keyword">end</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">merge_ins_l</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} {<span class="id" title="var">cmp</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">A</span> -&gt; <span class="id" title="var">bool</span>} {<span class="id" title="var">l</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span>} {<span class="id" title="var">x</span> : <span class="id" title="var">A</span>},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">merge</span> <span class="id" title="var">cmp</span> [<span class="id" title="var">x</span>] <span class="id" title="var">l</span> = <span class="id" title="var">ins</span> <span class="id" title="var">cmp</span> <span class="id" title="var">x</span> <span class="id" title="var">l</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">merge_ins_r</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} {<span class="id" title="var">cmp</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">A</span> -&gt; <span class="id" title="var">bool</span>} {<span class="id" title="var">l</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span>} {<span class="id" title="var">x</span> : <span class="id" title="var">A</span>},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">merge</span> <span class="id" title="var">cmp</span> <span class="id" title="var">l</span> [<span class="id" title="var">x</span>] = <span class="id" title="var">ins</span> <span class="id" title="var">cmp</span> <span class="id" title="var">x</span> <span class="id" title="var">l</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">merge_ins'</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} {<span class="id" title="var">cmp</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">A</span> -&gt; <span class="id" title="var">bool</span>} {<span class="id" title="var">l1</span> <span class="id" title="var">l2</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span>} {<span class="id" title="var">x</span> : <span class="id" title="var">A</span>},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">merge</span> <span class="id" title="var">cmp</span> (<span class="id" title="var">ins</span> <span class="id" title="var">cmp</span> <span class="id" title="var">x</span> <span class="id" title="var">l1</span>) (<span class="id" title="var">ins</span> <span class="id" title="var">cmp</span> <span class="id" title="var">x</span> <span class="id" title="var">l2</span>) =<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">ins</span> <span class="id" title="var">cmp</span> <span class="id" title="var">x</span> (<span class="id" title="var">ins</span> <span class="id" title="var">cmp</span> <span class="id" title="var">x</span> (<span class="id" title="var">merge</span> <span class="id" title="var">cmp</span> <span class="id" title="var">l1</span> <span class="id" title="var">l2</span>)).<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">merge_all_true</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} {<span class="id" title="var">cmp</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">A</span> -&gt; <span class="id" title="var">bool</span>} {<span class="id" title="var">l</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span>} {<span class="id" title="var">x</span> : <span class="id" title="var">A</span>},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">all</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">y</span> : <span class="id" title="var">A</span> =&gt; <span class="id" title="var">cmp</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span>) <span class="id" title="var">l</span> = <span class="id" title="var">true</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">merge</span> <span class="id" title="var">cmp</span> [<span class="id" title="var">x</span>] <span class="id" title="var">l</span> = <span class="id" title="var">x</span> :: <span class="id" title="var">l</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">merge_ind</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">P</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span> -&gt; <span class="id" title="var">list</span> <span class="id" title="var">A</span> -&gt; <span class="id" title="var">list</span> <span class="id" title="var">A</span> -&gt; <span class="id" title="keyword">Prop</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id" title="var">f</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">A</span> -&gt; <span class="id" title="var">bool</span>},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">forall</span> <span class="id" title="var">l</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span>, <span class="id" title="var">P</span> [] <span class="id" title="var">l</span> <span class="id" title="var">l</span>) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">forall</span> <span class="id" title="var">l</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span>, <span class="id" title="var">P</span> <span class="id" title="var">l</span> [] <span class="id" title="var">l</span>) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">forall</span> (<span class="id" title="var">h1</span> <span class="id" title="var">h2</span> : <span class="id" title="var">A</span>) (<span class="id" title="var">t1</span> <span class="id" title="var">t2</span> <span class="id" title="var">r</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">f</span> <span class="id" title="var">h1</span> <span class="id" title="var">h2</span> = <span class="id" title="var">true</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">P</span> <span class="id" title="var">t1</span> (<span class="id" title="var">h2</span> :: <span class="id" title="var">t2</span>) <span class="id" title="var">r</span> -&gt; <span class="id" title="var">P</span> (<span class="id" title="var">h1</span> :: <span class="id" title="var">t1</span>) (<span class="id" title="var">h2</span> :: <span class="id" title="var">t2</span>) (<span class="id" title="var">h1</span> :: <span class="id" title="var">r</span>)) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">forall</span> (<span class="id" title="var">h1</span> <span class="id" title="var">h2</span> : <span class="id" title="var">A</span>) (<span class="id" title="var">t1</span> <span class="id" title="var">t2</span> <span class="id" title="var">r</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">f</span> <span class="id" title="var">h1</span> <span class="id" title="var">h2</span> = <span class="id" title="var">false</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">P</span> (<span class="id" title="var">h1</span> :: <span class="id" title="var">t1</span>) <span class="id" title="var">t2</span> <span class="id" title="var">r</span> -&gt; <span class="id" title="var">P</span> (<span class="id" title="var">h1</span> :: <span class="id" title="var">t1</span>) (<span class="id" title="var">h2</span> :: <span class="id" title="var">t2</span>) (<span class="id" title="var">h2</span> :: <span class="id" title="var">r</span>)) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">l1</span> <span class="id" title="var">l2</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span>, <span class="id" title="var">P</span> <span class="id" title="var">l1</span> <span class="id" title="var">l2</span> (<span class="id" title="var">merge</span> <span class="id" title="var">f</span> <span class="id" title="var">l1</span> <span class="id" title="var">l2</span>).<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">all_merge</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">cmp</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">A</span> -&gt; <span class="id" title="var">bool</span>) (<span class="id" title="var">p</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">bool</span>) (<span class="id" title="var">l1</span> <span class="id" title="var">l2</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">all</span> <span class="id" title="var">p</span> (<span class="id" title="var">merge</span> <span class="id" title="var">cmp</span> <span class="id" title="var">l1</span> <span class="id" title="var">l2</span>) = <span class="id" title="var">all</span> <span class="id" title="var">p</span> <span class="id" title="var">l1</span> &amp;&amp; <span class="id" title="var">all</span> <span class="id" title="var">p</span> <span class="id" title="var">l2</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">any_merge</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">cmp</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">A</span> -&gt; <span class="id" title="var">bool</span>) (<span class="id" title="var">p</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">bool</span>) (<span class="id" title="var">l1</span> <span class="id" title="var">l2</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">any</span> <span class="id" title="var">p</span> (<span class="id" title="var">merge</span> <span class="id" title="var">cmp</span> <span class="id" title="var">l1</span> <span class="id" title="var">l2</span>) = <span class="id" title="var">any</span> <span class="id" title="var">p</span> <span class="id" title="var">l1</span> || <span class="id" title="var">any</span> <span class="id" title="var">p</span> <span class="id" title="var">l2</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">count_merge</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">cmp</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">A</span> -&gt; <span class="id" title="var">bool</span>) (<span class="id" title="var">p</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">bool</span>) (<span class="id" title="var">l1</span> <span class="id" title="var">l2</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">count</span> <span class="id" title="var">p</span> (<span class="id" title="var">merge</span> <span class="id" title="var">cmp</span> <span class="id" title="var">l1</span> <span class="id" title="var">l2</span>) = <span class="id" title="var">count</span> <span class="id" title="var">p</span> <span class="id" title="var">l1</span> + <span class="id" title="var">count</span> <span class="id" title="var">p</span> <span class="id" title="var">l2</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">merge_filter</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} {<span class="id" title="var">cmp</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">A</span> -&gt; <span class="id" title="var">bool</span>} {<span class="id" title="var">p</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">bool</span>} {<span class="id" title="var">l1</span> <span class="id" title="var">l2</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span>},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">merge</span> <span class="id" title="var">cmp</span> (<span class="id" title="var">filter</span> <span class="id" title="var">p</span> <span class="id" title="var">l1</span>) (<span class="id" title="var">filter</span> <span class="id" title="var">p</span> <span class="id" title="var">l2</span>) =<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">filter</span> <span class="id" title="var">p</span> (<span class="id" title="var">merge</span> <span class="id" title="var">cmp</span> <span class="id" title="var">l1</span> <span class="id" title="var">l2</span>).<br/>

<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">Permutation_merge</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} {<span class="id" title="var">f</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">A</span> -&gt; <span class="id" title="var">bool</span>} {<span class="id" title="var">l1</span> <span class="id" title="var">l2</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span>},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">Permutation</span> (<span class="id" title="var">merge</span> <span class="id" title="var">f</span> <span class="id" title="var">l1</span> <span class="id" title="var">l2</span>) (<span class="id" title="var">l1</span> ++ <span class="id" title="var">l2</span>).<br/>

<br/>
</div>

<div class="doc">
<a name="lab240"></a><h1 class="section">Rekursja wyższego rzędu (TODO)</h1>

<div class="paragraph"> </div>

 ACHTUNG: bardzo upośledzona wersja alfa.

<div class="paragraph"> </div>

    Pozostaje kwestia rekursji wyższego rzędu. Co to takiego? Ano dotychczas
    wszystkie nasze wywołania rekurencyjne były konkretne, czyli zaaplikowane
    do argumentów.

<div class="paragraph"> </div>

    Mogłoby się wydawać, że jest to jedyny możliwy sposób robienia wywołań
    rekurencyjnych, jednak nie jest tak. Wywołania rekurencyjne mogą mieć
    również inną, wyższorzędową postać, a mianowicie - możemy przekazać
    funkcję, którą właśnie definiujemy, jako argument do innej funkcji.

<div class="paragraph"> </div>

    Dlaczego jest to wywołanie rekurencyjne, skoro nie wywołujemy naszej
    funkcji? Ano dlatego, że tamta funkcja, która dostaje naszą jako
    argument, dostaje niejako możliwość robienia wywołań rekurencyjnych.
    W zależności od tego, co robi ta funkcja, wszystko może być ok (np.
    gdy ignoruje ona naszą funkcję i w ogóle jej nie używa) lub śmiertelnie
    niebezpieczne (gdy próbuje zrobić wywołanie rekurencyjne na strukturalnie
    większym argumencie).

<div class="paragraph"> </div>

    Sztoby za dużo nie godoć, bajszpil: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">Tree</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Node</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">list</span> (<span class="id" title="var">Tree</span> <span class="id" title="var">A</span>) -&gt; <span class="id" title="var">Tree</span> <span class="id" title="var">A</span>.<br/>

<br/>
<span class="id" title="var">Arguments</span> <span class="id" title="var">Node</span> {<span class="id" title="var">A</span>} <span class="id" title="var">_</span> <span class="id" title="var">_</span>.<br/>

<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" title="var">Tree</span></span> to typ drzew niepustych, które mogą mieć dowolną (ale skończoną)
    ilość poddrzew. Spróbujmy zdefiniować funkcję, która zwraca lustrzane
    odbicie drzewa. 
</div>
<div class="code">

<br/>
<span class="comment">(*<br/>
Fixpoint&nbsp;mirror&nbsp;{A&nbsp;:&nbsp;Type}&nbsp;(t&nbsp;:&nbsp;Tree&nbsp;A)&nbsp;:&nbsp;Tree&nbsp;A&nbsp;:=<br/>
match&nbsp;t&nbsp;with<br/>
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Node&nbsp;x&nbsp;ts&nbsp;=&gt;&nbsp;Node&nbsp;x&nbsp;(rev&nbsp;(map&nbsp;mirror&nbsp;ts))<br/>
end.<br/>
*)</span><br/>

<br/>
</div>

<div class="doc">
Nie jest to zbyt trudne. Rekurencyjnie odbijamy wszystkie poddrzewa za
    pomocą <span class="inlinecode"><span class="id" title="var">map</span></span> <span class="inlinecode"><span class="id" title="var">mirror</span></span>, a następnie odwracamy kolejność poddrzew z użyciem
    <span class="inlinecode"><span class="id" title="var">rev</span></span>. Chociaż poszło gładko, to mamy tu do czynienia z czymś, czego
    wcześniej nie widzieliśmy. Nie ma tu żadnego wywołania rekurencyjnego,
    a mimo to funkcja działa ok. Dlaczego? Właśnie dlatego, że wywołania
    rekurencyjne są robione przez funkcję <span class="inlinecode"><span class="id" title="var">map</span></span>. Mamy więc do czynienia z
    rekursją wyższego rzędu. 
</div>
<div class="code">

<br/>
<span class="comment">(*<br/>
Print&nbsp;Forall2.<br/>
<br/>
Inductive&nbsp;mirrorG&nbsp;{A&nbsp;:&nbsp;Type}&nbsp;:&nbsp;Tree&nbsp;A&nbsp;-&gt;&nbsp;Tree&nbsp;A&nbsp;-&gt;&nbsp;Prop&nbsp;:=<br/>
&nbsp;&nbsp;|&nbsp;mirrorG_0&nbsp;:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;forall&nbsp;(x&nbsp;:&nbsp;A)&nbsp;(ts&nbsp;rs&nbsp;:&nbsp;list&nbsp;(Tree&nbsp;A)),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Forall2&nbsp;mirrorG&nbsp;ts&nbsp;rs&nbsp;-&gt;&nbsp;mirrorG&nbsp;(Node&nbsp;x&nbsp;ts)&nbsp;(Node&nbsp;x&nbsp;(rev&nbsp;rs)).<br/>
<br/>
Definition&nbsp;mab&nbsp;{A&nbsp;B&nbsp;:&nbsp;Type}&nbsp;(f&nbsp;:&nbsp;A&nbsp;-&gt;&nbsp;B)&nbsp;:=<br/>
&nbsp;&nbsp;fix&nbsp;mab&nbsp;(l&nbsp;:&nbsp;list&nbsp;A)&nbsp;:&nbsp;list&nbsp;B&nbsp;:=<br/>
&nbsp;&nbsp;match&nbsp;l&nbsp;with<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;<span class="inlinecode"></span>&nbsp;=&gt;&nbsp;<span class="inlinecode"></span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;h&nbsp;::&nbsp;t&nbsp;=&gt;&nbsp;f&nbsp;h&nbsp;::&nbsp;mab&nbsp;t<br/>
&nbsp;&nbsp;end.<br/>
*)</span><br/>

<br/>
</div>

<div class="doc">
Inny przykład: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">Tree'</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Node'</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="keyword">forall</span> {<span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>}, (<span class="id" title="var">B</span> -&gt; <span class="id" title="var">Tree'</span> <span class="id" title="var">A</span>) -&gt; <span class="id" title="var">Tree'</span> <span class="id" title="var">A</span>.<br/>

<br/>
<span class="id" title="var">Arguments</span> <span class="id" title="var">Node'</span> {<span class="id" title="var">A</span>} <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>.<br/>

<br/>
</div>

<div class="doc">
Tym razem mamy drzewo, które może mieć naprawdę dowolną ilość poddrzew,
    ale jego poddrzewa są nieuporządkowane. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">mirror'</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">t</span> : <span class="id" title="var">Tree'</span> <span class="id" title="var">A</span>) : <span class="id" title="var">Tree'</span> <span class="id" title="var">A</span> :=<br/>
<span class="id" title="keyword">match</span> <span class="id" title="var">t</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Node'</span> <span class="id" title="var">x</span> <span class="id" title="var">B</span> <span class="id" title="var">ts</span> =&gt; <span class="id" title="var">Node'</span> <span class="id" title="var">x</span> <span class="id" title="var">B</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">b</span> : <span class="id" title="var">B</span> =&gt; <span class="id" title="var">mirror'</span> (<span class="id" title="var">ts</span> <span class="id" title="var">b</span>))<br/>
<span class="id" title="keyword">end</span>.<br/>
</div>
