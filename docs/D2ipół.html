<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link href="coqdoc.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="jquery-3.5.1.js"></script>
<script type="text/javascript" src="main.js"></script>
<script type="text/javascript" src="MyStyles.js"></script>
</head>
<h1 class="libtitle">D2ipół</h1>

<div class="code">

<br/>
</div>

<div class="doc">
W tym rozdziale będą różne formy indukcji/rekursji, których chwilowo nie
    chcę wstawiać do głównego tekstu rozdziałów D1 i D2, bo tam nie pasują.
    Prędzej czy później zostaną one z tymi rozdział zintegrowane (albo i nie -
    nie mamy pańskiego płaszcza i co nam pan zrobi?). 
<div class="paragraph"> </div>

<a name="lab232"></a><h1 class="section">Rekursja prymitywna (TODO)</h1>

</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
Wiemy już, że rekursja ogólna prowadzi do sprzeczności, a jedyną legalną
    formą rekursji jest rekursja prymitywna (i niektóre formy rekursji
    strukturalnej, o czym dowiemy się później). Funkcje rekurencyjne, które
    dotychczas pisaliśmy, były prymitywnie rekurencyjne, więc potrafisz
    już całkiem sprawnie posługiwać się tym rodzajem rekursji. Pozostaje
    nam zatem jedynie zbadać techniczne detale dotyczące sposobu realizacji
    rekursji prymitywnej w Coqu. W tym celu przyjrzyjmy się ponownie
    definicji dodawania: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Print</span> <span class="id" title="var">plus</span>.<br/>
<span class="comment">(*&nbsp;plus&nbsp;=<br/>
&nbsp;&nbsp;&nbsp;fix&nbsp;plus&nbsp;(n&nbsp;m&nbsp;:&nbsp;nat)&nbsp;{struct&nbsp;n}&nbsp;:&nbsp;nat&nbsp;:=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;match&nbsp;n&nbsp;with<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;0&nbsp;=&gt;&nbsp;m<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;S&nbsp;p&nbsp;=&gt;&nbsp;S&nbsp;(plus&nbsp;p&nbsp;m)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;nat&nbsp;-&gt;&nbsp;nat&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Możemy zaobserwować parę rzeczy. Pierwsza, techniczna sprawa: po
    <span class="inlinecode">=</span> widzimy nieznany nam konstrukt <span class="inlinecode"><span class="id" title="keyword">fix</span></span>. Pozwala on tworzyć
    anonimowe funkcje rekruencyjne, tak jak <span class="inlinecode"><span class="id" title="keyword">fun</span></span> pozwala tworzyć
    anonimowe funkcje nierekurencyjne. Funkcje zdefiniowane komendami 
    <span class="inlinecode"><span class="id" title="keyword">Fixpoint</span></span> i <span class="inlinecode"><span class="id" title="keyword">Definition</span></span> są w jęzku termów Coqa reprezentowane
    odpowiednio za pomocą <span class="inlinecode"><span class="id" title="keyword">fix</span></span> i <span class="inlinecode"><span class="id" title="keyword">fun</span></span>.

<div class="paragraph"> </div>

    Po drugie: za listą argumentów, a przed zwracanym typem, występuje
    adnotacja <span class="inlinecode">{<span class="id" title="keyword">struct</span></span> <span class="inlinecode"><span class="id" title="var">n</span>}</span>. Wskazuje ona, który z argumentów funkcji
    jest argumentem głównym. Dotychczas gdy definiowaliśmy funkcje
    rekurencyjne nigdy nie musieliśmy jej pisać, bo Coq zawsze domyślał
    się, który argument ma być główny. W poetyckiej polszczyźnie argument
    główny możemy wskazać mówiąc np., że "funkcja plus zdefiniowana jest
    przez rekursję po pierwszym argumencie" albo "funkcja plus zdefinowana
    jest przez rekursję po n".

<div class="paragraph"> </div>

    Czym jest argument główny? Spróbuję wyjasnić to w sposób operacyjny:
<ul class="doclist">
<li> jako argument główny możemy wskazać dowolny argument, którego typ
      jest induktywny

</li>
<li> Coq wymusza na nas, aby argumentem głównym wywołania rekurencyjnego
      był podterm argumentu głównego z obecnego wywołania

</li>
</ul>

<div class="paragraph"> </div>

    Dlaczego taki zabieg chroni nas przed sprzecznością? Przypomnij sobie,
    że termy typów induktywnych muszą być skończone. Parafrazując: są to
    drzewa o skończonej wysokości. Ich podtermy są od nich mniejsze, więc
    w kolejnych wywołaniach rekurencyjnych argument główny będzie malał,
    aż w końcu jego rozmiar skurczy się do zera. Wtedy rekursja zatrzyma
    się, bo nie będzie już żadnych podtermów, na których można by zrobić
    wywołanie rekurencyjne.

<div class="paragraph"> </div>

    Żeby lepiej zrozumieć ten mechanizm, zbadajmy najpierw relację bycia
    podtermem dla typów induktywnych. Relację tę opisują dwie proste zasady:
<ul class="doclist">
<li> po pierwsze, jeżeli dany term został zrobiony jakimś konstruktorem,
      to jego podtermami są rekurencyjne argumenty tego konstruktora.
      Przykład: <span class="inlinecode">0</span> jest podtermem <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode">0</span>, zaś <span class="inlinecode"><span class="id" title="var">nil</span></span> podtermem <span class="inlinecode"><span class="id" title="var">cons</span></span> <span class="inlinecode">42</span> <span class="inlinecode"><span class="id" title="var">nil</span></span>.

</li>
<li> po drugie, jeżeli <span class="inlinecode"><span class="id" title="var">t1</span></span> jest podtermem <span class="inlinecode"><span class="id" title="var">t2</span></span>, a <span class="inlinecode"><span class="id" title="var">t2</span></span> podtermem <span class="inlinecode"><span class="id" title="var">t3</span></span>,
      to <span class="inlinecode"><span class="id" title="var">t1</span></span> jest podtermem <span class="inlinecode"><span class="id" title="var">t3</span></span> — własność ta nazywa się przechodniością.
      Przykład: <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode">0</span> jest podtermem <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode">0)</span>, a zatem <span class="inlinecode">0</span> jest podtermem
      <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode">0)</span>. Podobnie <span class="inlinecode"><span class="id" title="var">nil</span></span> jest podtermem <span class="inlinecode"><span class="id" title="var">cons</span></span> <span class="inlinecode">666</span> <span class="inlinecode">(<span class="id" title="var">cons</span></span> <span class="inlinecode">42</span> <span class="inlinecode"><span class="id" title="var">nil</span>)</span> 
</li>
</ul>

<div class="paragraph"> </div>

<a name="lab233"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 Zdefiniuj relacje bycia podtermem dla liczb naturalnych i list. 
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
Udowodnij, że przytoczone wyżej przykłady nie są oszustwem.
    Komenda <span class="inlinecode"><span class="id" title="keyword">Goal</span></span> jest wygodna, gdyż używając jej nie musimy
    nadawać twierdzeniu nazwy. Użycie <span class="inlinecode"><span class="id" title="keyword">Qed</span></span> zapisze twierdzenie
    jako <span class="inlinecode"><span class="id" title="var">Unnamed_thm</span></span>, <span class="inlinecode"><span class="id" title="var">Unnamed_thm0</span></span>, <span class="inlinecode"><span class="id" title="var">Unnamed_thm1</span></span> etc. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Goal</span> <span class="id" title="var">subterm_nat</span> 0 (<span class="id" title="var">S</span> 0).<br/>

<br/>
<span class="id" title="keyword">Goal</span> <span class="id" title="var">subterm_list</span> <span class="id" title="var">nil</span> (<span class="id" title="var">cons</span> 42 <span class="id" title="var">nil</span>).<br/>

<br/>

<br/>

<br/>
</div>

<div class="doc">
<a name="lab234"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 Udowodnij, że relacje <span class="inlinecode"><span class="id" title="var">subterm_nat</span></span> oraz <span class="inlinecode"><span class="id" title="var">subterm_list</span></span> są antyzwrotne
    i przechodnie. Uwaga: to może być całkiem trudne. 
</div>
<div class="code">

<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">subterm_nat_antirefl</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, ~ <span class="id" title="var">subterm_nat</span> <span class="id" title="var">n</span> <span class="id" title="var">n</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">subterm_nat_trans</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span> <span class="id" title="var">c</span> : <span class="id" title="var">nat</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">subterm_nat</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span> -&gt; <span class="id" title="var">subterm_nat</span> <span class="id" title="var">b</span> <span class="id" title="var">c</span> -&gt; <span class="id" title="var">subterm_nat</span> <span class="id" title="var">a</span> <span class="id" title="var">c</span>.<br/>

<br/>

<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">subterm_list_antirefl</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">l</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span>), ~ <span class="id" title="var">subterm_list</span> <span class="id" title="var">l</span> <span class="id" title="var">l</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">subterm_list_trans</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">l1</span> <span class="id" title="var">l2</span> <span class="id" title="var">l3</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">subterm_list</span> <span class="id" title="var">l1</span> <span class="id" title="var">l2</span> -&gt; <span class="id" title="var">subterm_list</span> <span class="id" title="var">l2</span> <span class="id" title="var">l3</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">subterm_list</span> <span class="id" title="var">l1</span> <span class="id" title="var">l3</span>.<br/>

<br/>

<br/>
</div>

<div class="doc">
Jak widać, podtermy liczby naturalnej to liczby naturalne, które są od
    niej mniejsze, zaś podtermy listy to jej ogon, ogon ogona i tak dalej.
    Zero i lista pusta nie mają podtermów, gdyż są to przypadki bazowe,
    pochodzące od konstruktorów, które nie mają argumentów rekurencyjnych.

<div class="paragraph"> </div>

    Dla każdego typu induktywnego możemy zdefiniować relację bycia podtermem
    podobną do tych dla liczb naturalnych i list. Zauważmy jednak, że nie
    możemy za jednym zamachem zdefiniować relacji bycia podtermem dla
    wszystkich typów induktywnych, gdyż nie możemy w Coqu powiedzieć czegoś
    w stylu "dla wszystkich typów induktywnych". Możemy powiedzieć jedynie
    "dla wszystkich typów".

<div class="paragraph"> </div>

    Coq nie generuje jednak automatycznie takiej relacji, gdy definiujemy
    nowy typ induktywny. W jaki zatem sposób Coq sprawdza, czy jeden term
    jest podtermem drugiego? Otóż... w sumie, to nie sprawdza. Rzućmy okiem
    na następujący przykład: 
</div>
<div class="code">

<br/>
<span class="id" title="var">Fail</span> <span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">weird</span> (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) : <span class="id" title="var">unit</span> :=<br/>
<span class="id" title="keyword">match</span> <span class="id" title="var">n</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| 0 =&gt; <span class="id" title="var">tt</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">S</span> <span class="id" title="var">n'</span> =&gt; <span class="id" title="var">weird</span> 0<br/>
<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
Definicja zdaje się być poprawna: <span class="inlinecode">0</span> to przypadek bazowy, a gdy <span class="inlinecode"><span class="id" title="var">n</span></span>
    jest postaci <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n'</span></span>, wywołujemy funkcję rekurencyjnie na argumencie
    <span class="inlinecode">0</span>. <span class="inlinecode">0</span> jest podtermem <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n'</span></span>, a zatem wszystko powinno być dobrze.
    Dostajemy jednak następujący komunikat o błędzie: 
</div>
<div class="code">

<br/>
<span class="comment">(*&nbsp;Recursive&nbsp;definition&nbsp;of&nbsp;weird&nbsp;is&nbsp;ill-formed.<br/>
&nbsp;&nbsp;&nbsp;In&nbsp;environment<br/>
&nbsp;&nbsp;&nbsp;weird&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;unit<br/>
&nbsp;&nbsp;&nbsp;n&nbsp;:&nbsp;nat<br/>
&nbsp;&nbsp;&nbsp;n'&nbsp;:&nbsp;nat<br/>
&nbsp;&nbsp;&nbsp;Recursive&nbsp;call&nbsp;to&nbsp;weird&nbsp;has&nbsp;principal&nbsp;argument&nbsp;equal&nbsp;to&nbsp;<br/>
&nbsp;&nbsp;&nbsp;"0"&nbsp;instead&nbsp;of&nbsp;"n'".&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Komunikat ten głosi, że argumentem głównym wywołania rekurencyjnego jest
    <span class="inlinecode">0</span>, podczas gdy powinno być nim <span class="inlinecode"><span class="id" title="var">n'</span></span>. Wynika stąd jasno i wyraźnie, że
    jedynymi legalnymi argumentami w wywołaniu rekurencyjnym są te podtermy
    argumentu głównego, które zostają ujawnione w wyniku dopasowania do
    wzorca. Coq nie jest jednak głupi - jest głupszy, niż ci się wydaje, o
    czym świadczy poniższy przykład. 
</div>
<div class="code">

<br/>
<span class="id" title="var">Fail</span> <span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">fib</span> (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) : <span class="id" title="var">nat</span> :=<br/>
<span class="id" title="keyword">match</span> <span class="id" title="var">n</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| 0 =&gt; 0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| 1 =&gt; 1<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">S</span> (<span class="id" title="var">S</span> <span class="id" title="var">n'</span>) =&gt; <span class="id" title="var">fib</span> <span class="id" title="var">n'</span> + <span class="id" title="var">fib</span> (<span class="id" title="var">S</span> <span class="id" title="var">n'</span>)<br/>
<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
Funkcja ta próbuje policzyć n-tą liczbę Fibonacciego:
    https://en.wikipedia.org/wiki/Fibonacci_number, ale
    słabo jej to wychodzi, gdyż dostajemy następujący błąd: 
</div>
<div class="code">

<br/>
<span class="comment">(*&nbsp;Recursive&nbsp;definition&nbsp;of&nbsp;fib&nbsp;is&nbsp;ill-formed.<br/>
&nbsp;&nbsp;&nbsp;In&nbsp;environment<br/>
&nbsp;&nbsp;&nbsp;fib&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;nat<br/>
&nbsp;&nbsp;&nbsp;n&nbsp;:&nbsp;nat<br/>
&nbsp;&nbsp;&nbsp;n0&nbsp;:&nbsp;nat<br/>
&nbsp;&nbsp;&nbsp;n'&nbsp;:&nbsp;nat<br/>
&nbsp;&nbsp;&nbsp;Recursive&nbsp;call&nbsp;to&nbsp;fib&nbsp;has&nbsp;principal&nbsp;argument&nbsp;equal&nbsp;to&nbsp;<br/>
&nbsp;&nbsp;&nbsp;"S&nbsp;n'"&nbsp;instead&nbsp;of&nbsp;one&nbsp;of&nbsp;the&nbsp;following&nbsp;variables:&nbsp;<br/>
&nbsp;&nbsp;&nbsp;"n0"&nbsp;"n'".&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Mimo, że <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n'</span></span> jest podtermem <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n'</span>)</span>, który pochodzi z dopasowania
    do wzorca, to Coq nie jest w stanie zauważyć tego faktu. W komunikacie
    o błędzie pojawia się za to tajemnicza zmienna <span class="inlinecode"><span class="id" title="var">n0</span></span>, której w naszym
    kodzie nigdzie nie ma. Sposobem na poradzenie sobie z problemem jest
    pokazanie Coqowi palcem, o co nam chodzi: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">fib</span> (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) : <span class="id" title="var">nat</span> :=<br/>
<span class="id" title="keyword">match</span> <span class="id" title="var">n</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| 0 =&gt; 0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| 1 =&gt; 1<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">S</span> (<span class="id" title="var">S</span> <span class="id" title="var">n'</span> <span class="id" title="keyword">as</span> <span class="id" title="var">n''</span>) =&gt; <span class="id" title="var">fib</span> <span class="id" title="var">n'</span> + <span class="id" title="var">fib</span> <span class="id" title="var">n''</span><br/>
<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
Tym razem Coq widzi, że <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n'</span></span> jest podtermem <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n'</span>)</span>, gdyż explicite
    nadaliśmy temu termowi nazwę <span class="inlinecode"><span class="id" title="var">n''</span></span>, używając do tego klauzli <span class="inlinecode"><span class="id" title="keyword">as</span></span>.

<div class="paragraph"> </div>

    Ufff...  udało nam się przebrnąć przez techniczne detale działania
    rekursji strukturalnej. Mogłoby się wydawać, że jest ona mechanizmem
    bardzo upośledzonym, ale z doświadczenia wiesz już, że w praktyce
    omówione wyżej problemy występują raczej rzadko.

<div class="paragraph"> </div>

    Mogłoby się też wydawać, że skoro wywołania rekurencyjne możemy robić
    tylko na bezpośrednich podtermach dopasowanych we wzorcu, to nie da się
    zdefiniować prawie żadnej ciekawej funkcji. Jak zobaczymy w kolejnych
    podrozdziałach, wcale tak nie jest. Dzięki pewnej sztuczce za pomocą
    rekursji strukturalnej można wyrazić rekursję dobrze ufundowaną, która
    na pierwszy rzut oka jest dużo potężniejsza i daje nam wiele możliwości
    definiowania różnych ciekawych funkcji. 
<div class="paragraph"> </div>

<a name="lab235"></a><h4 class="section">Ćwiczenie (dzielenie)</h4>

<div class="paragraph"> </div>

 Zdefiniuj funkcję <span class="inlinecode"><span class="id" title="var">div</span></span>, która implementuje dzielenie całkowitoliczbowe.
    Żeby uniknąć problemów z dzieleniem przez <span class="inlinecode">0</span>, <span class="inlinecode"><span class="id" title="var">div</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span> będziemy
    interpretować jako <span class="inlinecode"><span class="id" title="var">n</span></span> podzielone przez <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span>, czyli np. <span class="inlinecode"><span class="id" title="var">div</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">0</span>
    to n/1, <span class="inlinecode"><span class="id" title="var">div</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">1</span> to n/2 etc. Uwaga: to ćwiczenie pojawia się właśnie
    w tym miejscu nieprzypadkowo. 
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
<a name="lab236"></a><h1 class="section">Jak działa indukcja (nie, nie kuchenka) (TODO)</h1>

<div class="paragraph"> </div>

<a name="lab237"></a><h1 class="section">Rekursja strukturalna (TODO)</h1>

<div class="paragraph"> </div>

<a name="lab238"></a><h1 class="section">Rekursja jako najlepszość</h1>

<div class="paragraph"> </div>

 Znamy już podstawowe typy induktywne, jak liczby naturalne oraz
    listy elementów typu <span class="inlinecode"><span class="id" title="var">A</span></span>. Wiemy też, że ich induktywność objawia
    się głównie w tym, że możemy definiować funkcje przez rekursję
    strukturalną po argumentach tych typów oraz dowodzić przez indukcję.

<div class="paragraph"> </div>

    W takim podejściu indukcja i sama induktywność typów induktywnych
    wydają się być czymś w rodzaju domina - wystarczy popchnąć pierwsze
    kilka kostek (przypadki bazowe) i zapewnić, że pozostałe kostki są
    dobrze ułożone (przypadki rekurencyjne), aby zainicjować reakcję
    łańcuchową, która będzie przewracać kostki w nieskończoność.

<div class="paragraph"> </div>

    Nie jest to jednak jedyny sposób patrzenia na typy induktywne. W tym
    podrozdziale spróbuję przedstawić inny sposób patrzenia, w którym typ
    induktywny to najlepszy typ do robienia termów o pewnym kształcie, a
    rekursja to zmiana kształtu z lepszego na gorszy, ale bardziej
    użyteczny.

<div class="paragraph"> </div>

    Żeby móc patrzeć z tej perspektywy musimy najpierw ustalić, czym
    jest kształt. Uwaga: "kształt" nie jest pojęciem technicznym i nie
    ma ścisłej definicji - używam tego słowa, żeby ułatwić pracę twojej
    wyobraźni.

<div class="paragraph"> </div>

    Czym jest kształt termu? Najprościej rzecz ujmując każdy term jest
    drzewkiem, którego korzeniem jest jakiś konstrukt językowy (stała,
    konstruktor, uprzednio zdefiniowana funkcja, dopasowanie do wzorca,
    <span class="inlinecode"><span class="id" title="keyword">let</span></span>, lub cokolwiek innego), a jego poddrzewa to argumenty tego
    konstruktu.

<div class="paragraph"> </div>

    Dla przykładu, termy typu <span class="inlinecode"><span class="id" title="var">nat</span></span> mogą mieć takie kształty:
<ul class="doclist">
<li> <span class="inlinecode">0</span> - stała

</li>
<li> <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode">0))</span> - konstruktor

</li>
<li> <span class="inlinecode"><span class="id" title="var">plus</span></span> <span class="inlinecode">0</span> <span class="inlinecode">5</span>, <span class="inlinecode"><span class="id" title="var">mult</span></span> <span class="inlinecode">0</span> <span class="inlinecode">5</span> - uprzednio zdefiniowana funkcja

</li>
<li> <span class="inlinecode"><span class="id" title="keyword">if</span></span> <span class="inlinecode"><span class="id" title="var">andb</span></span> <span class="inlinecode"><span class="id" title="var">false</span></span> <span class="inlinecode"><span class="id" title="var">false</span></span> <span class="inlinecode"><span class="id" title="keyword">then</span></span> <span class="inlinecode">42</span> <span class="inlinecode"><span class="id" title="keyword">else</span></span> <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode">42</span> - <span class="inlinecode"><span class="id" title="keyword">if</span></span>

</li>
<li> <span class="inlinecode"><span class="id" title="keyword">match</span></span> <span class="inlinecode">0</span> <span class="inlinecode"><span class="id" title="keyword">with</span></span> <span class="inlinecode">|</span> <span class="inlinecode">0</span> <span class="inlinecode">=&gt;</span> <span class="inlinecode">666</span> <span class="inlinecode">|</span> <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">_</span></span> <span class="inlinecode">=&gt;</span> <span class="inlinecode">123</span> - dopasowanie do wzorca

</li>
<li> <span class="inlinecode"><span class="id" title="var">length</span></span> <span class="inlinecode">[<span class="id" title="var">true</span>;</span> <span class="inlinecode"><span class="id" title="var">false</span>]</span> - uprzednio zdefiniowana funkcja

</li>
<li> <span class="inlinecode"><span class="id" title="keyword">let</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">:=</span> <span class="inlinecode"><span class="id" title="keyword">Prop</span></span> <span class="inlinecode"><span class="id" title="tactic">in</span></span> <span class="inlinecode">16</span> - <span class="inlinecode"><span class="id" title="keyword">let</span></span>

</li>
<li> ... i wiele, wiele innych!

</li>
</ul>

<div class="paragraph"> </div>

    Tak wiele różnych sposobów robienia termów to niesamowite bogactwo,
    więc żeby zgodnie z przysłowiem od tego przybytku nie rozbolała nas
    głowa, musimy pomyśleć o nich w nieco bardziej jednorodny sposób.
    Rozwiązanie jest na szczęście bajecznie proste: zauważ, że wszystkie
    powyższe konstrukty językowe można po prostu zawinąć w funkcję, która
    bierze pewną liczbę argumentów (być może zero) i zwraca coś typu
    <span class="inlinecode"><span class="id" title="var">nat</span></span>.

<div class="paragraph"> </div>

    To jednak nie w pełni mityguje przyszły-niedoszły ból głowy. O ile
    mamy teraz jednorodny sposób myślenia o kształtach termów, to i tak
    kształtów tych mogą być olbrzymie ilości. Z tego powodu dokonamy
    samoograniczenia i zamiast o wszystkich możliwych kształtach termów
    będziemy wybiórczo skupiać naszą uwagę tylko na tych kształtach,
    które akurat będą nas interesować.

<div class="paragraph"> </div>

    Dla przykładu, możemy interesować się termami typu <span class="inlinecode"><span class="id" title="var">nat</span></span> zrobionymi
    wyłącznie za pomocą:
<ul class="doclist">
<li> konstruktorów <span class="inlinecode">0</span> i <span class="inlinecode"><span class="id" title="var">S</span></span>

</li>
<li> konstruktora <span class="inlinecode">0</span>, stałej <span class="inlinecode">1</span> oraz funkcji <span class="inlinecode"><span class="id" title="var">plus</span></span> <span class="inlinecode">2</span>

</li>
<li> funkcji <span class="inlinecode"><span class="id" title="var">plus</span></span> i stałych <span class="inlinecode">5</span> oraz <span class="inlinecode">42</span>

</li>
<li> funkcji <span class="inlinecode"><span class="id" title="var">mult</span></span> i stałej <span class="inlinecode">1</span>

</li>
<li> funkcji <span class="inlinecode"><span class="id" title="var">length</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">list</span></span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> 
</li>
</ul>

<div class="paragraph"> </div>

<a name="lab239"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 Narysuj jakieś nietrywialne termy typu <span class="inlinecode"><span class="id" title="var">nat</span></span> o takich kształtach. 
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
<a name="lab240"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 Liczbę <span class="inlinecode"><span class="id" title="var">n</span></span> da się wyrazić za pomocą termu <span class="inlinecode"><span class="id" title="var">t</span></span>, jeżeli <span class="inlinecode"><span class="id" title="var">t</span></span> oblicza
    się do <span class="inlinecode"><span class="id" title="var">n</span></span>, tzn. komenda <span class="inlinecode"><span class="id" title="keyword">Compute</span></span> <span class="inlinecode"><span class="id" title="var">t</span></span> daje w wyniku <span class="inlinecode"><span class="id" title="var">n</span></span>.

<div class="paragraph"> </div>

    Pytanie: termy o których z powyższych kształtów mogą wyrazić
    wszystkie liczby naturalne? 
<div class="paragraph"> </div>

<a name="lab241"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 Liczba <span class="inlinecode"><span class="id" title="var">n</span></span> ma unikalną reprezentację za pomocą termów o danym
    kształcie, gdy jest tylko jeden term <span class="inlinecode"><span class="id" title="var">t</span></span>, który reprezentuje <span class="inlinecode"><span class="id" title="var">n</span></span>.

<div class="paragraph"> </div>

    Pytanie: które z powyższych sposobów unikalnie reprezentują
    wszystkie liczby naturalne? 
<div class="paragraph"> </div>

 Sporo już osiągnęliśmy w wyklarowywaniu pojęcia kształtu, ale
    zatrzymajmy się na chwilę i zastanówmy się, czy jest ono zgodne
    z naszymi intuicjami.

<div class="paragraph"> </div>

    Okazuje się, że otóż nie do końca, bo w naszej obecnej formulacji
    kształty <span class="inlinecode">(0,</span> <span class="inlinecode"><span class="id" title="var">plus</span>)</span> oraz <span class="inlinecode">(1,</span> <span class="inlinecode"><span class="id" title="var">mult</span>)</span> są różne, podczas gdy obrazki
    (narysuj je!) jasno pokazują nam, że np. <span class="inlinecode"><span class="id" title="var">plus</span></span> <span class="inlinecode">0</span> <span class="inlinecode">(<span class="id" title="var">plus</span></span> <span class="inlinecode">0</span> <span class="inlinecode">0)</span> oraz
    <span class="inlinecode"><span class="id" title="var">mult</span></span> <span class="inlinecode">1</span> <span class="inlinecode">(<span class="id" title="var">mult</span></span> <span class="inlinecode">1</span> <span class="inlinecode">1)</span> wyglądają bardzo podobnie, tylko nazwy są różne.

<div class="paragraph"> </div>

    Dlatego też modyfikujemy nasze pojęcie kształtu - teraz kształtem
    zamiast stałych i funkcji, jak <span class="inlinecode">0</span> i <span class="inlinecode"><span class="id" title="var">plus</span></span>, nazywać będziemy typy
    tych stałych i funkcji. Tak więc kształtem termów zrobionych z <span class="inlinecode">0</span>
    i <span class="inlinecode"><span class="id" title="var">plus</span></span> będzie <span class="inlinecode"><span class="id" title="var">nat</span></span> (bo <span class="inlinecode">0</span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span></span>) i <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> (bo
    <span class="inlinecode"><span class="id" title="var">plus</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">nat</span></span>). Teraz jest już jasne, że <span class="inlinecode">1</span> i <span class="inlinecode"><span class="id" title="var">mult</span></span>
    dają dokładnie ten sam kształt, bo typem <span class="inlinecode">1</span> jest <span class="inlinecode"><span class="id" title="var">nat</span></span>, zaś typem
    <span class="inlinecode"><span class="id" title="var">mult</span></span> jest <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">nat</span></span>.

<div class="paragraph"> </div>

    Zauważmy, że można nasze pojęcie kształtu jeszcze troszkę uprościć:
<ul class="doclist">
<li> po pierwsze, każdą stałą można traktować jako funkcję biorącą
      argument typu <span class="inlinecode"><span class="id" title="var">unit</span></span>, np. możemy <span class="inlinecode">0</span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> reprezentować za pomocą
      funkcji <span class="inlinecode"><span class="id" title="var">Z</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">unit</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> zdefiniowanej jako
      <span class="inlinecode"><span class="id" title="var">Z</span></span> <span class="inlinecode">:=</span> <span class="inlinecode"><span class="id" title="keyword">fun</span></span> <span class="inlinecode"><span class="id" title="var">_</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">unit</span></span> <span class="inlinecode">=&gt;</span> <span class="inlinecode">0</span>

</li>
<li> po drugie, funkcje biorące wiele argumentów możemy reprezentować za
      pomocą funkcji biorących jeden argument, np.
      <span class="inlinecode"><span class="id" title="var">plus</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> możemy reprezentować za pomocą
      <span class="inlinecode"><span class="id" title="var">plus'</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">*</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">nat</span></span>, który jest zdefiniowany jako
      <span class="inlinecode"><span class="id" title="var">plus'</span></span> <span class="inlinecode">:=</span> <span class="inlinecode"><span class="id" title="keyword">fun</span></span> <span class="inlinecode">'(<span class="id" title="var">n</span>,</span> <span class="inlinecode"><span class="id" title="var">m</span>)</span> <span class="inlinecode">=&gt;</span> <span class="inlinecode"><span class="id" title="var">plus</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span>

</li>
<li> po trzecie, ponieważ kodziedzina wszystkich funkcji jest taka
      sama (w naszym przypadku <span class="inlinecode"><span class="id" title="var">nat</span></span>), możemy połączyć wiele funkcji w
      jedną, np. <span class="inlinecode">0</span> i <span class="inlinecode"><span class="id" title="var">plus</span></span> możemy razem reprezentować jako
      <span class="inlinecode"><span class="id" title="var">Zplus</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">unit</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">*</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">nat</span></span>, zdefiniowaną jako
      <span class="inlinecode"><span class="id" title="var">Zplus</span></span> <span class="inlinecode">:=</span> <span class="inlinecode"><span class="id" title="keyword">fun</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">=&gt;</span> <span class="inlinecode"><span class="id" title="keyword">match</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode"><span class="id" title="keyword">with</span></span> <span class="inlinecode">|</span> <span class="inlinecode"><span class="id" title="var">inl</span></span> <span class="inlinecode"><span class="id" title="var">_</span></span> <span class="inlinecode">=&gt;</span> <span class="inlinecode">0</span> <span class="inlinecode">|</span> <span class="inlinecode"><span class="id" title="var">inr</span></span> <span class="inlinecode">(<span class="id" title="var">n</span>,</span> <span class="inlinecode"><span class="id" title="var">m</span>)</span> <span class="inlinecode">=&gt;</span> <span class="inlinecode"><span class="id" title="var">plus</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span> <span class="inlinecode"><span class="id" title="keyword">end</span></span>

</li>
</ul>

<div class="paragraph"> </div>

    Dzięki tym uproszczeniom (albo utrudnieniom, zależy kogo spytacie)
    możemy teraz jako kształt traktować nie funkcje albo same ich typy,
    lecz tylko jeden typ, który jest dziedziną takiej połączonej funkcji.
    Tak więc zarówno <span class="inlinecode">(0,</span> <span class="inlinecode"><span class="id" title="var">plus</span>)</span> jak i <span class="inlinecode">(1,</span> <span class="inlinecode"><span class="id" title="var">mult</span>)</span> są kształtu
    <span class="inlinecode"><span class="id" title="var">unit</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">*</span> <span class="inlinecode"><span class="id" title="var">nat</span></span>. Ma to sporo sensu: drzewa reprezentujące te termy
    są albo liściem (reprezentowanym przez <span class="inlinecode"><span class="id" title="var">unit</span></span>), albo węzłem, który
    rozgałęzia się na dwa poddrzewa (reprezentowanym przez <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">*</span> <span class="inlinecode"><span class="id" title="var">nat</span></span>).

<div class="paragraph"> </div>

    Ale to jeszcze nie wszystko. Przecież <span class="inlinecode"><span class="id" title="var">nat</span></span> to nie jedyny typ, w
    którym można robić termy o kształcie <span class="inlinecode"><span class="id" title="var">unit</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">*</span> <span class="inlinecode"><span class="id" title="var">nat</span></span>. Jeżeli
    przyjrzymy się, jak wyglądają termy zrobione za pomocą (<span class="inlinecode"><span class="id" title="var">true</span>,</span> <span class="inlinecode"><span class="id" title="var">andb</span></span>)
    albo <span class="inlinecode">(<span class="id" title="var">false</span>,</span> <span class="inlinecode"><span class="id" title="var">orb</span>)</span>, to okaże się, że... mają one dokładnie ten sam
    kształt, mimo że według naszej definicji ich kształt to
    <span class="inlinecode"><span class="id" title="var">unit</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">bool</span></span> <span class="inlinecode">*</span> <span class="inlinecode"><span class="id" title="var">bool</span></span>, czyli niby coś innego.

<div class="paragraph"> </div>

    Ostatnim stadium ewolucji naszego pojęcia kształtu jest taki oto
    zestaw definicji:
<ul class="doclist">
<li> kształt to funkcja <span class="inlinecode"><span class="id" title="var">F</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Type</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="keyword">Type</span></span>

</li>
<li> realizacją kształtu <span class="inlinecode"><span class="id" title="var">F</span></span> jest typ <span class="inlinecode"><span class="id" title="var">X</span></span> oraz funkcja <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">F</span></span> <span class="inlinecode"><span class="id" title="var">X</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">X</span></span>

</li>
</ul>

<div class="paragraph"> </div>

    Widzimy teraz, że <span class="inlinecode">(0,</span> <span class="inlinecode"><span class="id" title="var">plus</span>)</span>, <span class="inlinecode">(1,</span> <span class="inlinecode"><span class="id" title="var">mult</span>)</span>, <span class="inlinecode">(<span class="id" title="var">true</span>,</span> <span class="inlinecode"><span class="id" title="var">andb</span>)</span> oraz
    <span class="inlinecode">(<span class="id" title="var">false</span>,</span> <span class="inlinecode"><span class="id" title="var">orb</span>)</span> nie są kształtami, lecz realizacjami kształtu
    <span class="inlinecode"><span class="id" title="var">F</span></span> <span class="inlinecode">:=</span> <span class="inlinecode"><span class="id" title="keyword">fun</span></span> <span class="inlinecode"><span class="id" title="var">X</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Type</span></span> <span class="inlinecode">=&gt;</span> <span class="inlinecode">1</span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">X</span></span> <span class="inlinecode">*</span> <span class="inlinecode"><span class="id" title="var">X</span></span>.

<div class="paragraph"> </div>

    Pora powoli zmierzać ku konkluzji. Na początku powiedzieliśmy, że
    typ induktywny to najlepszy typ do robienia termów o pewnym kształcie.
    Jakim kształcie, zapytasz pewnie, i jak objawia się owa najlepszość?
    Czas się tego dowiedzieć.

<div class="paragraph"> </div>

    Definiując typ induktywny podajemy jego konstruktory, a całą resztę,
    czyli możliwość definiowania przez dopasowanie do wzorca i rekursję,
    reguły eliminacji etc. dostajemy za darmo. Nie dziwota więc, że to
    właśnie konstruktory są realizacją kształtu, którego dany typ jest
    najlepszym przykładem.

<div class="paragraph"> </div>

    Napiszmy to jeszcze raz, dla jasności: typ induktywny to najlepszy
    sposób robienia termów o kształcie realizowanym przez jego
    konstruktory.

<div class="paragraph"> </div>

    W naszym <span class="inlinecode"><span class="id" title="var">nat</span></span>owym przykładzie oznacza to, że <span class="inlinecode"><span class="id" title="var">nat</span></span> jest najlepszym
    sposobem robienia termów o kształcie <span class="inlinecode"><span class="id" title="var">F</span></span> <span class="inlinecode">:=</span> <span class="inlinecode"><span class="id" title="keyword">fun</span></span> <span class="inlinecode"><span class="id" title="var">X</span></span> <span class="inlinecode">=&gt;</span> <span class="inlinecode"><span class="id" title="var">unit</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">X</span></span>, czyli
    termów w kształcie "sznurków" (konstruktor <span class="inlinecode"><span class="id" title="var">S</span></span> to taki supełek na
    sznurku, a <span class="inlinecode">0</span> reprezentuje koniec sznurka). Są też inne realizacje
    tego sznurkowego kształtu, jak np. stała <span class="inlinecode">42</span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> i funkcja
    <span class="inlinecode"><span class="id" title="var">plus</span></span> <span class="inlinecode">8</span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> albo stała <span class="inlinecode"><span class="id" title="var">true</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">bool</span></span> i funkcja
    <span class="inlinecode"><span class="id" title="var">negb</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">bool</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span></span>, albo nawet zdanie <span class="inlinecode"><span class="id" title="var">False</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Prop</span></span> oraz
    negacja <span class="inlinecode"><span class="id" title="var">not</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Prop</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>, ale żadna z nich nie jest najlepsza.

<div class="paragraph"> </div>

    Jak objawia się najlepszość typu induktywnego? Ano, dwojako:
<ul class="doclist">
<li> po pierwsze, objawia się w postaci rekursora, który bierze jako
      argument docelową realizację danego kształtu i przerabia term
      typu induktywnego, podmieniając najlepszą realizację na docelową

</li>
<li> po drugie, rekursor jest unikalny, czyli powyższa podmiana
      realizacji odbywa się w jedyny słuszny sposób

</li>
</ul>

<div class="paragraph"> </div>

    Żeby nie być gołosłownym, zobaczmy przykłady: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">nat_rec'</span> {<span class="id" title="var">X</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">z</span> : <span class="id" title="var">X</span>) (<span class="id" title="var">s</span> : <span class="id" title="var">X</span> -&gt; <span class="id" title="var">X</span>) (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) : <span class="id" title="var">X</span> :=<br/>
<span class="id" title="keyword">match</span> <span class="id" title="var">n</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| 0 =&gt; <span class="id" title="var">z</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">S</span> <span class="id" title="var">n'</span> =&gt; <span class="id" title="var">s</span> (<span class="id" title="var">nat_rec'</span> <span class="id" title="var">z</span> <span class="id" title="var">s</span> <span class="id" title="var">n'</span>)<br/>
<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
Tak wygląda rekursor dla liczb naturalnych. Widzimy, że "zmiana
    realizacji" termu o danym kształcie intuicyjnie polega na tym, że
    bierzemy term i zamieniamy <span class="inlinecode">0</span> na <span class="inlinecode"><span class="id" title="var">z</span></span>, a <span class="inlinecode"><span class="id" title="var">S</span></span> na <span class="inlinecode"><span class="id" title="var">s</span></span>, czyli dla
    przykładu liczba <span class="inlinecode">4</span> (czyli <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode">0)))</span>) zostanie zamieniona
    na <span class="inlinecode"><span class="id" title="var">s</span></span> <span class="inlinecode">(<span class="id" title="var">s</span></span> <span class="inlinecode">(<span class="id" title="var">s</span></span> <span class="inlinecode">(<span class="id" title="var">s</span></span> <span class="inlinecode"><span class="id" title="var">z</span>)))</span>. Jeszcze konkretniejszy przykład:
    <span class="inlinecode"><span class="id" title="var">nat_rec'</span></span> <span class="inlinecode"><span class="id" title="var">true</span></span> <span class="inlinecode"><span class="id" title="var">negb</span></span> zamieni liczbę <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode">0)))</span> w
    <span class="inlinecode"><span class="id" title="var">negb</span></span> <span class="inlinecode">(<span class="id" title="var">negb</span></span> <span class="inlinecode">(<span class="id" title="var">negb</span></span> <span class="inlinecode">(<span class="id" title="var">negb</span></span> <span class="inlinecode"><span class="id" title="var">true</span>)))</span>. Oczywiście term ten następnie
    oblicza się do <span class="inlinecode"><span class="id" title="var">true</span></span>. 
<div class="paragraph"> </div>

<a name="lab242"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 Mamy <span class="inlinecode"><span class="id" title="var">nat_rec'</span></span> <span class="inlinecode"><span class="id" title="var">true</span></span> <span class="inlinecode"><span class="id" title="var">negb</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span></span>, a zatem zmiana realizacji
    sznurka z <span class="inlinecode">(0,</span> <span class="inlinecode"><span class="id" title="var">S</span>)</span> na <span class="inlinecode">(<span class="id" title="var">true</span>,</span> <span class="inlinecode"><span class="id" title="var">negb</span>)</span> odpowiada sprawdzeniu jakiejś
    właściwości liczb naturalnych. Jakiej?

<div class="paragraph"> </div>

    Pisząc wprost: zdefiniuj bezpośrednio przez rekursję taką funkcję
    <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span></span>, że <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span>,</span> <span class="inlinecode"><span class="id" title="var">nat_rec'</span></span> <span class="inlinecode"><span class="id" title="var">true</span></span> <span class="inlinecode"><span class="id" title="var">negb</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span>
    (oczywiście musisz udowodnić, że wszystko się zgadza). 
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
Uwaga: Coq domyślnie generuje dla typu "rekursor", ale ma on na
    myśli coś innego, niż my: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="var">nat_rec</span>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;nat_rec&nbsp;:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;forall&nbsp;P&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;Set,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P&nbsp;0&nbsp;-&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(forall&nbsp;n&nbsp;:&nbsp;nat,&nbsp;P&nbsp;n&nbsp;-&gt;&nbsp;P&nbsp;(S&nbsp;n))&nbsp;-&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;forall&nbsp;n&nbsp;:&nbsp;nat,&nbsp;P&nbsp;n&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Coqowe <span class="inlinecode"><span class="id" title="var">nat_rec</span></span> to w zasadzie to samo, co <span class="inlinecode"><span class="id" title="var">nat_ind</span></span>, czyli reguła
    indukcji, tyle że kodziedziną motywu nie jest <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>, lecz <span class="inlinecode"><span class="id" title="keyword">Set</span></span>
    (możesz myśleć, że <span class="inlinecode"><span class="id" title="keyword">Set</span></span> to to samo co <span class="inlinecode"><span class="id" title="keyword">Type</span></span>).

<div class="paragraph"> </div>

    Podobieństwo naszego <span class="inlinecode"><span class="id" title="var">nat_rec'</span></span> oraz reguły indukcji nie jest
    przypadkowe - myślenie o typach induktywnych w przedstawiony wyżej
    sposób jest najlepszym sposobem na spamiętanie wszystkich możliwych
    reguł rekursji, indukcji i tympodobnych. A robi się to tak (naszym
    przykładem tym razem będzie typ <span class="inlinecode"><span class="id" title="var">list</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span>).

<div class="paragraph"> </div>

    Krok pierwszy: każda lista to albo <span class="inlinecode"><span class="id" title="var">nil</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">list</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> albo
    <span class="inlinecode"><span class="id" title="var">cons</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">list</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">list</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> zaaplikowany do głowy <span class="inlinecode"><span class="id" title="var">h</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span> i
    ogona <span class="inlinecode"><span class="id" title="var">t</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">list</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span>.

<div class="paragraph"> </div>

    Krok drugi: skoro tak, to <span class="inlinecode"><span class="id" title="var">list</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> jest najlepszym sposobem na
    robienie termów w kształcie <span class="inlinecode">(<span class="id" title="var">nil</span>,</span> <span class="inlinecode"><span class="id" title="var">cons</span>)</span>.

<div class="paragraph"> </div>

    Krok trzeci: wobec tego mamy (a raczej musimy sobie zrobić)
    rekursor <span class="inlinecode"><span class="id" title="var">list_rec'</span></span>, który, gdy damy mu inną realizację kształtu
    <span class="inlinecode"><span class="id" title="var">F</span></span> <span class="inlinecode">:=</span> <span class="inlinecode"><span class="id" title="keyword">fun</span></span> <span class="inlinecode"><span class="id" title="var">X</span></span> <span class="inlinecode">=&gt;</span> <span class="inlinecode"><span class="id" title="var">unit</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">*</span> <span class="inlinecode"><span class="id" title="var">X</span></span>, to podmieni on <span class="inlinecode"><span class="id" title="var">nil</span></span> i <span class="inlinecode"><span class="id" title="var">cons</span></span>y w
    dowolnej liście <span class="inlinecode"><span class="id" title="var">l</span></span> na tą inną realizację. Jego typ wygląda tak: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">list_rec'_type</span> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>)        <span class="comment">(*&nbsp;parametr&nbsp;<span class="inlinecode"><span class="id" title="var">list</span></span>&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">P</span> : <span class="id" title="keyword">Type</span>)        <span class="comment">(*&nbsp;inna&nbsp;realizacja&nbsp;kształtu&nbsp;-&nbsp;typ&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">n</span> : <span class="id" title="var">P</span>)           <span class="comment">(*&nbsp;inna&nbsp;realizacja&nbsp;kształtu&nbsp;-&nbsp;<span class="inlinecode"><span class="id" title="var">nil</span></span>&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">c</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">P</span> -&gt; <span class="id" title="var">P</span>) <span class="comment">(*&nbsp;inna&nbsp;realizacja&nbsp;kształtu&nbsp;-&nbsp;<span class="inlinecode"><span class="id" title="var">cons</span></span>&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">l</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span>),     <span class="comment">(*&nbsp;lista,&nbsp;w&nbsp;której&nbsp;chcemy&nbsp;zrobić&nbsp;podmianę&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">P</span>. <span class="comment">(*&nbsp;wynik&nbsp;podmiany&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Krócej można ten typ zapisać tak: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">list_rec'_type'</span> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">A</span> <span class="id" title="var">P</span> : <span class="id" title="keyword">Type</span>, <span class="id" title="var">P</span> -&gt; (<span class="id" title="var">A</span> -&gt; <span class="id" title="var">P</span> -&gt; <span class="id" title="var">P</span>) -&gt; <span class="id" title="var">list</span> <span class="id" title="var">A</span> -&gt; <span class="id" title="var">P</span>.<br/>

<br/>
</div>

<div class="doc">
Implementacja jest banalna: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">list_rec'</span><br/>
&nbsp;&nbsp;{<span class="id" title="var">A</span> <span class="id" title="var">P</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">n</span> : <span class="id" title="var">P</span>) (<span class="id" title="var">c</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">P</span> -&gt; <span class="id" title="var">P</span>) (<span class="id" title="var">l</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span>) : <span class="id" title="var">P</span> :=<br/>
<span class="id" title="keyword">match</span> <span class="id" title="var">l</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">nil</span> =&gt; <span class="id" title="var">n</span> <span class="comment">(*&nbsp;podmieniamy&nbsp;<span class="inlinecode"><span class="id" title="var">nil</span></span>&nbsp;na&nbsp;<span class="inlinecode"><span class="id" title="var">n</span></span>...&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">cons</span> <span class="id" title="var">h</span> <span class="id" title="var">t</span> =&gt; <span class="id" title="var">c</span> <span class="id" title="var">h</span> (<span class="id" title="var">list_rec'</span> <span class="id" title="var">n</span> <span class="id" title="var">c</span> <span class="id" title="var">t</span>) <span class="comment">(*&nbsp;...&nbsp;a&nbsp;<span class="inlinecode"><span class="id" title="var">cons</span></span>&nbsp;na&nbsp;<span class="inlinecode"><span class="id" title="var">c</span></span>&nbsp;*)</span><br/>
<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
Krok czwarty: żeby uzyskać regułę indukcji, bierzemy rekursor i
    zamieniamy <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Type</span></span> na <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">list</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>. Żeby uzyskać
    najbardziej ogólną regułę eliminacji, używamy <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">list</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="keyword">Type</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">list_ind'_type</span> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id" title="var">P</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span> -&gt; <span class="id" title="keyword">Prop</span>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">n</span> : <span class="id" title="var">P</span> <span class="id" title="var">nil</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">c</span> : <span class="id" title="keyword">forall</span> (<span class="id" title="var">h</span> : <span class="id" title="var">A</span>) (<span class="id" title="var">t</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span>), <span class="id" title="var">P</span> <span class="id" title="var">t</span> -&gt; <span class="id" title="var">P</span> (<span class="id" title="var">cons</span> <span class="id" title="var">h</span> <span class="id" title="var">t</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">l</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span>), <span class="id" title="var">P</span> <span class="id" title="var">l</span>.<br/>

<br/>
</div>

<div class="doc">
Oczywiście musimy też dostosować typy argumentów. Może to prowadzić
    do pojawienia się nowych argumentów. <span class="inlinecode"><span class="id" title="var">c</span></span> w rekursorze miało typ
    <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">P</span></span>. Pierwszy argument typu <span class="inlinecode"><span class="id" title="var">A</span></span> musimy nazwać <span class="inlinecode"><span class="id" title="var">h</span></span>, żeby
    móc go potem użyć. Ostatnie <span class="inlinecode"><span class="id" title="var">P</span></span> to konkluzja, która musi być postaci
    <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">(<span class="id" title="var">cons</span></span> <span class="inlinecode"><span class="id" title="var">h</span></span> <span class="inlinecode"><span class="id" title="var">t</span>)</span>, ale <span class="inlinecode"><span class="id" title="var">t</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">list</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> nigdzie nie ma, więc je dodajemy.
    Pierwsze <span class="inlinecode"><span class="id" title="var">P</span></span> zmienia się w hipotezę indukcyjną <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">t</span></span>. 
<div class="paragraph"> </div>

 Krok piąty: definicja reguły indukcji jest prawie taka sama jak
    poprzednio (musimy uwzględnić pojawienie się <span class="inlinecode"><span class="id" title="var">t</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">list</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> jako
    argumentu w <span class="inlinecode"><span class="id" title="var">c</span></span>. Poza tym drobnym detalem zmieniają się tylko
    typy: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">list_ind'</span><br/>
&nbsp;&nbsp;{<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>}<br/>
&nbsp;&nbsp;{<span class="id" title="var">P</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span> -&gt; <span class="id" title="keyword">Prop</span>}<br/>
&nbsp;&nbsp;(<span class="id" title="var">n</span> : <span class="id" title="var">P</span> <span class="id" title="var">nil</span>)<br/>
&nbsp;&nbsp;(<span class="id" title="var">c</span> : <span class="id" title="keyword">forall</span> (<span class="id" title="var">h</span> : <span class="id" title="var">A</span>) (<span class="id" title="var">t</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span>), <span class="id" title="var">P</span> <span class="id" title="var">t</span> -&gt; <span class="id" title="var">P</span> (<span class="id" title="var">cons</span> <span class="id" title="var">h</span> <span class="id" title="var">t</span>))<br/>
&nbsp;&nbsp;(<span class="id" title="var">l</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;: <span class="id" title="var">P</span> <span class="id" title="var">l</span> :=<br/>
<span class="id" title="keyword">match</span> <span class="id" title="var">l</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">nil</span> =&gt; <span class="id" title="var">n</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">cons</span> <span class="id" title="var">h</span> <span class="id" title="var">t</span> =&gt; <span class="id" title="var">c</span> <span class="id" title="var">h</span> <span class="id" title="var">t</span> (<span class="id" title="var">list_ind'</span> <span class="id" title="var">n</span> <span class="id" title="var">c</span> <span class="id" title="var">t</span>)<br/>
<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
Włala, mamy regułę indukcji.

<div class="paragraph"> </div>

    Na sam koniec wypadałoby jeszcze opisać drobne detale dotyczące
    najlepszości. Czy skoro <span class="inlinecode"><span class="id" title="var">nat</span></span> jest najlepszym typem do robienia
    termów w kształcie sznurków, to znaczy, że inne realizacje tego
    kształtu są gorsze? I w jaki sposób objawia się ich gorszość?

<div class="paragraph"> </div>

    Odpowiedź na pierwsze pytanie jest skomplikowańsza niż bym chciał:
    <span class="inlinecode"><span class="id" title="var">nat</span></span> jest najlepsze, ale inne typy też mogą być najlepsze.
    Rozważmy poniższy typ: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">nat'</span> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Z'</span> : <span class="id" title="var">nat'</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">S'</span> : <span class="id" title="var">nat'</span> -&gt; <span class="id" title="var">nat'</span>.<br/>

<br/>
</div>

<div class="doc">
Jako, że <span class="inlinecode"><span class="id" title="var">nat'</span></span> jest typem induktywnym, to jest najlepszym sposobem
    robienia termów w kształcie <span class="inlinecode"><span class="id" title="var">F</span></span> <span class="inlinecode">:=</span> <span class="inlinecode"><span class="id" title="keyword">fun</span></span> <span class="inlinecode"><span class="id" title="var">X</span></span> <span class="inlinecode">=&gt;</span> <span class="inlinecode"><span class="id" title="var">unit</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">X</span></span>. Ale jak to?
    Przecież najlepsze dla tego kształtu jest <span class="inlinecode"><span class="id" title="var">nat</span></span>! Tak, to prawda.
    Czy zatem <span class="inlinecode"><span class="id" title="var">nat'</span></span> jest gorsze? Nie: oba te typy, <span class="inlinecode"><span class="id" title="var">nat</span></span> i <span class="inlinecode"><span class="id" title="var">nat'</span></span>,
    są najlepsze.

<div class="paragraph"> </div>

    Wynika stąd ciekawa konkluzja: <span class="inlinecode"><span class="id" title="var">nat'</span></span> to w zasadzie to samo co
    <span class="inlinecode"><span class="id" title="var">nat</span></span>, tylko inaczej nazwane. Fakt ten łatwo jest udowodnić:
    mając <span class="inlinecode"><span class="id" title="var">nat</span></span>owy sznurek możemy za pomocą <span class="inlinecode"><span class="id" title="var">nat_rec'</span></span> przerobić
    go na <span class="inlinecode"><span class="id" title="var">nat'</span></span>owy sznurek. Podobnie <span class="inlinecode"><span class="id" title="var">nat'</span></span>owy sznurek można
    za pomocą <span class="inlinecode"><span class="id" title="var">nat'_rec'</span></span> przerobić na <span class="inlinecode"><span class="id" title="var">nat</span></span>owy sznurek. Widać na
    oko, że obie te funkcje są swoimi odwrotnościami, a zatem typy
    <span class="inlinecode"><span class="id" title="var">nat</span></span> i <span class="inlinecode"><span class="id" title="var">nat'</span></span> są izomorficzne, czyli mają takie same elementy
    i takie same właściwości. 
<div class="paragraph"> </div>

<a name="lab243"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 Zdefiniuj funkcje <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">nat'</span></span> i <span class="inlinecode"><span class="id" title="var">g</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">nat'</span></span>,
    które spełniają
    <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span>,</span> <span class="inlinecode"><span class="id" title="var">g</span></span> <span class="inlinecode">(<span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">n</span>)</span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">n</span></span> oraz
    <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat'</span>,</span> <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode">(<span class="id" title="var">g</span></span> <span class="inlinecode"><span class="id" title="var">n</span>)</span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">n</span></span>. Nie musisz w tym celu używać
    <span class="inlinecode"><span class="id" title="var">nat_rec'</span></span> ani <span class="inlinecode"><span class="id" title="var">nat'_rec'</span></span> (no chyba, że chcesz). 
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
Drugie pytanie brzmiało: w czym objawia się brak najlepszości innych
    realizacji danego kształtu? Odpowiedź jest prosta: skoro najlepszość
    to unikalny rekursor, to brak najlepszości oznacza brak unikalnego
    rekursora. Przeżyjmy to na przykładzie:

<div class="paragraph"> </div>

    Używając rekursora dla <span class="inlinecode"><span class="id" title="var">nat</span></span> możemy podmienić <span class="inlinecode"><span class="id" title="var">S</span></span> na negację, a
    <span class="inlinecode">0</span> na <span class="inlinecode"><span class="id" title="var">false</span></span>, i otrzymać dzięki temu funkcję sprawdzającą, czy
    długość sznurka (czyli liczby naturalnej) jest nieparzysta. Czy
    dla innych realizacji tego samego kształtu też możemy tak zrobić?

<div class="paragraph"> </div>

    Nie zawsze. Rozważmy typ <span class="inlinecode"><span class="id" title="var">unit</span></span> wraz ze stałą <span class="inlinecode"><span class="id" title="var">tt</span></span> i funkcją
    <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode">:=</span> <span class="inlinecode"><span class="id" title="keyword">fun</span></span> <span class="inlinecode"><span class="id" title="var">_</span></span> <span class="inlinecode">=&gt;</span> <span class="inlinecode"><span class="id" title="var">tt</span></span>, które realizują ten sam kształt co <span class="inlinecode"><span class="id" title="var">nat</span></span>,
    <span class="inlinecode">0</span> i <span class="inlinecode"><span class="id" title="var">S</span></span>. Zauważmy, że <span class="inlinecode"><span class="id" title="var">tt</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">tt</span></span>, a zatem różne sznurki
    obliczają się do tej samej wartości. Jest to sytuacja zgoła
    odmienna od <span class="inlinecode"><span class="id" title="var">nat</span></span>owej - różne ilości <span class="inlinecode"><span class="id" title="var">S</span></span>ów dają różne liczby
    naturalne.

<div class="paragraph"> </div>

    Gdybyśmy mieli dla tej realizacji rekursor podmieniający <span class="inlinecode"><span class="id" title="var">f</span></span> na
    jakąś funkcję <span class="inlinecode"><span class="id" title="var">g</span></span>, zaś <span class="inlinecode"><span class="id" title="var">tt</span></span> na stałą <span class="inlinecode"><span class="id" title="var">x</span></span>, to niechybnie doszłoby
    do katastrofy. Dla przykładu, gdybyśmy próbowali tak jak wyżej
    sprawdzić, czy długość sznurka jest nieparzysta, zamieniając <span class="inlinecode"><span class="id" title="var">tt</span></span>
    na <span class="inlinecode"><span class="id" title="var">false</span></span>, zaś <span class="inlinecode"><span class="id" title="var">f</span></span> na <span class="inlinecode"><span class="id" title="var">negb</span></span>, to wynikiem zamiany dla <span class="inlinecode"><span class="id" title="var">tt</span></span> byłoby
    <span class="inlinecode"><span class="id" title="var">false</span></span>, zaś dla <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">tt</span></span> byłoby to <span class="inlinecode"><span class="id" title="var">negb</span></span> <span class="inlinecode"><span class="id" title="var">false</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">true</span></span>. To jednak
    prowadzi do sprzeczności, bo <span class="inlinecode"><span class="id" title="var">tt</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">tt</span></span>. Wyniki podmiany dla
    sznurków obliczających się do równych wartości musza być takie
    same.

<div class="paragraph"> </div>

    Oczywiście <span class="inlinecode"><span class="id" title="var">unit</span></span>, <span class="inlinecode"><span class="id" title="var">tt</span></span> i <span class="inlinecode"><span class="id" title="var">f</span></span> to bardzo patologiczna realizacja
    sznurkowego kształtu. Czy są jakieś mniej patologiczne realizacje,
    które umożliwiają podmiankę, która pozwala sprawdzić nieparzystość
    długości sznurka?

<div class="paragraph"> </div>

    Tak. Przykładem takiej realizacji jest... <span class="inlinecode"><span class="id" title="var">bool</span></span>, <span class="inlinecode"><span class="id" title="var">false</span></span> i <span class="inlinecode"><span class="id" title="var">negb</span></span>
    (a rzeczona podmianka, to w tym przypadku po prostu funkcja
    identycznościowa).

<div class="paragraph"> </div>

    Czy znaczy to, że <span class="inlinecode"><span class="id" title="var">bool</span></span>, <span class="inlinecode"><span class="id" title="var">false</span></span> i <span class="inlinecode"><span class="id" title="var">negb</span></span> to najlepsza realizacja
    sznurkowego kształtu? Nie - da się znaleźć całą masę podmianek,
    które <span class="inlinecode"><span class="id" title="var">nat</span></span> umożliwia, a <span class="inlinecode"><span class="id" title="var">bool</span></span>, <span class="inlinecode"><span class="id" title="var">false</span></span> i <span class="inlinecode"><span class="id" title="var">negb</span></span> - nie (joł, sprawdź
    to - wcale nie kłamię).

<div class="paragraph"> </div>

    Cóż, to by było na tyle. W ramach pożegnania z tym spojrzeniem na
    typy induktywne napiszę jeszcze tylko, że nie jest ono skuteczne
    zawsze i wszędzie. Działa jedynie dla prostych typów zrobionych
    z enumeracji, rekurencji i parametrów. Żeby myśleć w ten sposób
    np. o indeksowanych rodzinach typów trzeba mieć nieco mocniejszą
    wyobraźnię. 
<div class="paragraph"> </div>

<a name="lab244"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 Rozważmy poniższe typy:
<ul class="doclist">
<li> <span class="inlinecode"><span class="id" title="var">unit</span></span>

</li>
<li> <span class="inlinecode"><span class="id" title="var">bool</span></span>

</li>
<li> <span class="inlinecode"><span class="id" title="var">option</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span>

</li>
<li> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">*</span> <span class="inlinecode"><span class="id" title="var">B</span></span>

</li>
<li> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">B</span></span>

</li>
<li> <span class="inlinecode"><span class="id" title="tactic">exists</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span>,</span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span>

</li>
<li> <span class="inlinecode"><span class="id" title="var">nat</span></span>

</li>
<li> <span class="inlinecode"><span class="id" title="var">list</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span>

</li>
</ul>

<div class="paragraph"> </div>

    Dla każdego z nich:
<ul class="doclist">
<li> znajdź kształt, którego jest on najlepszą realizacją

</li>
<li> napisz typ rekursora

</li>
<li> zaimplementuj rekursor

</li>
<li> zaimplementuj bezpośrednio za pomocą rekursora jakąś ciekawą
      funkcję

</li>
<li> z typu rekursora wyprowadź typ reguły indukcji (oczywiście bez
      podglądania za pomocą komendy <span class="inlinecode"><span class="id" title="keyword">Print</span></span>... nie myśl też o białym
      niedźwiedziu)

</li>
<li> zaimplementuj regułę indukcji

</li>
<li> spróbuj bezpośrednio użyć reguły indukcji, by udowodnić jakiś
      fakt na temat zaimplementowanej uprzednio za pomocą rekursora
      funkcji 
</li>
</ul>

</div>
<div class="code">

<br/>

<br/>

<br/>
</div>

<div class="doc">
<a name="lab245"></a><h1 class="section">Reguły eliminacji (TODO)</h1>

<div class="paragraph"> </div>

<a name="lab246"></a><h1 class="section">Rekursja monotoniczna</h1>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <span class="id" title="var">X3</span>.<br/>

<br/>
</div>

<div class="doc">
Czas na omówienie pewnej ciekawej, ale średnio użytecznej formy rekursji
    (z pamięci nie jestem w stanie przytoczyć więcej niż dwóch sztampowych
    przykładów jej użycia), a jest nią rekursja monotoniczna (zwana też
    czasem rekursją zagnieżdżoną, ale nie będziemy używać tej nazwy, gdyż
    dotychczas używaliśmy jej na określenie rekursji, w której arguemntem
    wywołania rekurencyjnego jest wynik innego wywołania rekurencyjnego).

<div class="paragraph"> </div>

    Cóż to za zwierzątko, rekursja monotoniczna? Żeby się tego dowiedzieć,
    przypomnijmy sobie najpierw, jak technicznie w Coqu zrealizowana jest
    rekursja strukturalna. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">plus</span> (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) : <span class="id" title="var">nat</span> -&gt; <span class="id" title="var">nat</span> :=<br/>
<span class="id" title="keyword">match</span> <span class="id" title="var">n</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| 0 =&gt; <span class="id" title="keyword">fun</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span> =&gt; <span class="id" title="var">m</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">S</span> <span class="id" title="var">n'</span> =&gt; <span class="id" title="keyword">fun</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span> =&gt; <span class="id" title="var">S</span> (<span class="id" title="var">plus</span> <span class="id" title="var">n'</span> <span class="id" title="var">m</span>)<br/>
<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
Tak oto definicja funkcji plus, lecz zapisana nieco inaczej, niż gdy
    widzieliśmy ją ostatnim razem. Tym razem prezentujemy ją jako funkcję
    biorącą jeden argument typu <span class="inlinecode"><span class="id" title="var">nat</span></span> i zwracającą funkcję z typu <span class="inlinecode"><span class="id" title="var">nat</span></span> w
    typ <span class="inlinecode"><span class="id" title="var">nat</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">plus'</span> : <span class="id" title="var">nat</span> -&gt; <span class="id" title="var">nat</span> -&gt; <span class="id" title="var">nat</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">fix</span> <span class="id" title="var">f</span> (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) : <span class="id" title="var">nat</span> -&gt; <span class="id" title="var">nat</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">n</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 0 =&gt; <span class="id" title="keyword">fun</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span> =&gt; <span class="id" title="var">m</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">S</span> <span class="id" title="var">n'</span> =&gt; <span class="id" title="keyword">fun</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span> =&gt; <span class="id" title="var">S</span> (<span class="id" title="var">f</span> <span class="id" title="var">n'</span> <span class="id" title="var">m</span>)<br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
Ale komenda <span class="inlinecode"><span class="id" title="keyword">Fixpoint</span></span> jest jedynie cukrem syntaktycznym - funkcję <span class="inlinecode"><span class="id" title="var">plus</span></span>
    możemy równie dobrze zdefiniować bez niej, posługując się jedynie komendą
    <span class="inlinecode"><span class="id" title="keyword">Definition</span></span>, a wyrażeniem, które nam to umożliwia, jest <span class="inlinecode"><span class="id" title="keyword">fix</span></span>. <span class="inlinecode"><span class="id" title="keyword">fix</span></span>
    działa podobnie jak <span class="inlinecode"><span class="id" title="keyword">fun</span></span>, ale pozwala dodatkowo nadać definiowanej przez
    siebie funkcji nazwę, dzięki czemu możemy robić wywołania rekurencyjne.

<div class="paragraph"> </div>

    Czym więc jest rekursja monotoniczna? Z rekursją monotoniczną mamy do
    czynienia, gdy za pomocą <span class="inlinecode"><span class="id" title="keyword">fix</span></span>a (czyli przez rekursję) definiujemy
    funkcję, która zwraca inną funkcję, i ta zwracana funkcja także jest
    zdefiniowana za pomocą <span class="inlinecode"><span class="id" title="keyword">fix</span></span>a (czyli przez rekursję). Oczywiście to
    tylko pierwszy krok - wynikowa funkcja również może zwracać funkcję,
    która jest zdefiniowana za pomocą <span class="inlinecode"><span class="id" title="keyword">fix</span></span>a i tak dalej.

<div class="paragraph"> </div>

    Widać zatem jak na dłoni, że <span class="inlinecode"><span class="id" title="var">plus</span></span> ani <span class="inlinecode"><span class="id" title="var">plus'</span></span> nie są przykładami
    rekursji monotonicznej. Wprawdzie definiują one za pomocą <span class="inlinecode"><span class="id" title="keyword">fix</span></span>a
    (lub komendy <span class="inlinecode"><span class="id" title="keyword">Fixpoint</span></span>) funkcję, która zwraca inną funkcję, ale ta
    zwracana funkcja nie jest zdefiniowana za pomocą <span class="inlinecode"><span class="id" title="keyword">fix</span></span>a, lecz za
    pomocą <span class="inlinecode"><span class="id" title="keyword">fun</span></span>, a więc nie jest rekurencyjna.

<div class="paragraph"> </div>

    Podsumowując: rekursja jest monotoniczna, jeżeli w definicji
    funkcji pojawiają się co najmniej dwa wystąpienia <span class="inlinecode"><span class="id" title="keyword">fix</span></span>, jedno
    wewnątrz drugiego (przy czym rzecz jasna <span class="inlinecode"><span class="id" title="keyword">Fixpoint</span></span> też liczy
    się jako <span class="inlinecode"><span class="id" title="keyword">fix</span></span>).

<div class="paragraph"> </div>

    No to skoro już wiemy, czas zobaczyć przykład jakiejś funkcji, która
    jest zdefiniowana przez rekursję monotoniczną. 
</div>
<div class="code">

<br/>
<span class="id" title="var">Fail</span> <span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">ack</span> (<span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>) : <span class="id" title="var">nat</span> :=<br/>
<span class="id" title="keyword">match</span> <span class="id" title="var">n</span>, <span class="id" title="var">m</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| 0, <span class="id" title="var">m</span> =&gt; <span class="id" title="var">S</span> <span class="id" title="var">m</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">S</span> <span class="id" title="var">n'</span>, 0 =&gt; <span class="id" title="var">ack</span> <span class="id" title="var">n'</span> 1<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">S</span> <span class="id" title="var">n'</span>, <span class="id" title="var">S</span> <span class="id" title="var">m'</span> =&gt; <span class="id" title="var">ack</span> <span class="id" title="var">n'</span> (<span class="id" title="var">ack</span> (<span class="id" title="var">S</span> <span class="id" title="var">n'</span>) <span class="id" title="var">m'</span>)<br/>
<span class="id" title="keyword">end</span>.<br/>

<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;The&nbsp;command&nbsp;has&nbsp;indeed&nbsp;failed&nbsp;with&nbsp;message:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Cannot&nbsp;guess&nbsp;decreasing&nbsp;argument&nbsp;of&nbsp;fix.&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Powyższa funkcja zwana jest funkcją Ackermanna, gdyż wymyślił ją...
    zgadnij kto. Jest ona całkiem sławna, choć z zupełnie innych powodów
    niż te, dla których my się jej przyglądamy. Nie oblicza ona niczego
    specjalnie użytecznego - jej wynikami są po prostu bardzo duże liczby.
    Jeżeli nie wierzysz, spróbuj policzyć ręcznie <span class="inlinecode"><span class="id" title="var">ack</span></span> <span class="inlinecode">4</span> <span class="inlinecode">2</span> - zdziwisz się.

<div class="paragraph"> </div>

    Jak widać, Coq nie akceptuje powyższej definicji. Winny temu jest rzecz
    jasna kształt rekursji. Dla <span class="inlinecode"><span class="id" title="var">n</span></span> równego <span class="inlinecode">0</span> zwracamy <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span>, co jest ok.
    Dla <span class="inlinecode"><span class="id" title="var">n</span></span> postaci <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n'</span></span> i <span class="inlinecode"><span class="id" title="var">m</span></span> równego <span class="inlinecode">0</span> robimy wywołanie rekurencyjne
    na <span class="inlinecode"><span class="id" title="var">n'</span></span> i <span class="inlinecode">1</span>, co również jest ok. Jednak jeżeli <span class="inlinecode"><span class="id" title="var">n</span></span> i <span class="inlinecode"><span class="id" title="var">m</span></span> odpowednio
    są postaci <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n'</span></span> i <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">m'</span></span>, to robimy wywołanie rekurencyjne postaci
    <span class="inlinecode"><span class="id" title="var">ack</span></span> <span class="inlinecode"><span class="id" title="var">n'</span></span> <span class="inlinecode">(<span class="id" title="var">ack</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n'</span>)</span> <span class="inlinecode"><span class="id" title="var">m'</span>)</span>. W wewnętrznym wywołaniu rekurencyjnym pierwszy
    argument jest taki sam jak obecny. Gdyby argumentem głównym był drugi
    argument, to jest tym bardziej źle, gdyż w zewnętrznym wywołaniu
    rekurencyjnym nie jest nim <span class="inlinecode"><span class="id" title="var">m'</span></span>, lecz <span class="inlinecode"><span class="id" title="var">ack</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n'</span>)</span> <span class="inlinecode"><span class="id" title="var">m'</span></span>. Nie ma się więc
    co dziwić, że Coq nie może zgadnąć, który argument ma być argumentem
    głównym.

<div class="paragraph"> </div>

    Mimo, że Coq nie akceptuje tej definicji, to wydaje się ona być całkiem
    spoko. Żaden z argumentów nie może wprawdzie posłużyć nam za argument
    główny, ale jeżeli rozważymy ich zachowanie jako całość, to okazuje się,
    że w każdym wywołaniu rekurencyjnym mamy dwie możliwości:
<ul class="doclist">
<li> albo pierwszy argument się zmniejsza

</li>
<li> albo pierwszy argument się nie zmienia, ale drugi argument się
      zmniejsza

</li>
</ul>

<div class="paragraph"> </div>

    Możemy z tego wywnioskować, że jeżeli wywołamy <span class="inlinecode"><span class="id" title="var">ack</span></span> na argumentach
    <span class="inlinecode"><span class="id" title="var">n</span></span> i <span class="inlinecode"><span class="id" title="var">m</span></span>, to w ogólności najpierw <span class="inlinecode"><span class="id" title="var">m</span></span> będzie się zmniejszał, ale
    ponieważ musi kiedyś spaść do zera, to wtedy <span class="inlinecode"><span class="id" title="var">n</span></span> będzie musiał się
    zmniejszyć. Oczywiście wtedy w kolejnym wywołaniu zaczynamy znowu z
    jakimś <span class="inlinecode"><span class="id" title="var">m</span></span>, które potem się zmniejsza, aż w końcu znowu zmniejszy
    się <span class="inlinecode"><span class="id" title="var">n</span></span> i tak dalej, aż do chwili, gdy <span class="inlinecode"><span class="id" title="var">n</span></span> spadnie do zera. Wtedy
    rekursja musi się skończyć.

<div class="paragraph"> </div>

    Jednym z typowych zastosowań rekursji zagnieżdżonej jest radzenie
    sobie z takimi właśnie przypadkami, w których mamy ciąg argumentów
    i pierwszy maleje, lub pierwszy stoi w miejscu a drugi maleje i tak
    dalej. Zobaczmy więc, jak techniki tej można użyć do zdefiniowania
    funkcji Ackermanna. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">ack</span> (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) : <span class="id" title="var">nat</span> -&gt; <span class="id" title="var">nat</span> :=<br/>
<span class="id" title="keyword">match</span> <span class="id" title="var">n</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| 0 =&gt; <span class="id" title="var">S</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">S</span> <span class="id" title="var">n'</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">fix</span> <span class="id" title="var">ack'</span> (<span class="id" title="var">m</span> : <span class="id" title="var">nat</span>) : <span class="id" title="var">nat</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">m</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 0 =&gt; <span class="id" title="var">ack</span> <span class="id" title="var">n'</span> 1<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">S</span> <span class="id" title="var">m'</span> =&gt; <span class="id" title="var">ack</span> <span class="id" title="var">n'</span> (<span class="id" title="var">ack'</span> <span class="id" title="var">m'</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span><br/>
<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
Zauważmy przede wszystkim, że nieco zmienia się wygląd typu naszej
    funkcji. Jest on wprawdzie dokładnie taki sam (<span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">nat</span></span>),
    ale zapisujemy go inaczej. Robimy to by podkreslić, że wynikiem <span class="inlinecode"><span class="id" title="var">ack</span></span>
    jest funkcja. W przypadku gdy <span class="inlinecode"><span class="id" title="var">n</span></span> jest postaci <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n'</span></span> zdefiniowana
    jest ona za pomocą <span class="inlinecode"><span class="id" title="keyword">fix</span></span>a tak, jak wyglądają dwie ostatnie klauzule
    dopasowania z oryginalnej definicji, ale z wywołaniem <span class="inlinecode"><span class="id" title="var">ack</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n'</span>)</span> <span class="inlinecode"><span class="id" title="var">m'</span></span>
    zastąpionym przez <span class="inlinecode"><span class="id" title="var">ack'</span></span> <span class="inlinecode"><span class="id" title="var">m'</span></span>. Tak więc funkcja <span class="inlinecode"><span class="id" title="var">ack'</span></span> reprezentuje
    częściową aplikację <span class="inlinecode"><span class="id" title="var">ack</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span>. 
</div>
<div class="code">

<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">ack_eq</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">ack</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> =<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">n</span>, <span class="id" title="var">m</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 0, <span class="id" title="var">_</span> =&gt; <span class="id" title="var">S</span> <span class="id" title="var">m</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">S</span> <span class="id" title="var">n'</span>, 0 =&gt; <span class="id" title="var">ack</span> <span class="id" title="var">n'</span> 1<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">S</span> <span class="id" title="var">n'</span>, <span class="id" title="var">S</span> <span class="id" title="var">m'</span> =&gt; <span class="id" title="var">ack</span> <span class="id" title="var">n'</span> (<span class="id" title="var">ack</span> (<span class="id" title="var">S</span> <span class="id" title="var">n'</span>) <span class="id" title="var">m'</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">n</span>, <span class="id" title="var">m</span>; <span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">ack_big</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">m</span> &lt; <span class="id" title="var">ack</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">n</span> <span class="id" title="keyword">as</span> [| <span class="id" title="var">n'</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">cbn</span>. <span class="id" title="tactic">intro</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">le_n</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">m</span> <span class="id" title="keyword">as</span> [| <span class="id" title="var">m'</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">cbn</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">lt_trans</span> <span class="id" title="keyword">with</span> 1.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">le_n</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">IHn'</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">specialize</span> (<span class="id" title="var">IHn'</span> (<span class="id" title="var">ack</span> (<span class="id" title="var">S</span> <span class="id" title="var">n'</span>) <span class="id" title="var">m'</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">ack_eq</span>. <span class="id" title="var">lia</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">ack_big'</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n1</span> <span class="id" title="var">n2</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">n1</span> &lt;= <span class="id" title="var">n2</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">m1</span> <span class="id" title="var">m2</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">m1</span> &lt;= <span class="id" title="var">m2</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">ack</span> <span class="id" title="var">n1</span> <span class="id" title="var">m1</span> &lt;= <span class="id" title="var">ack</span> <span class="id" title="var">n2</span> <span class="id" title="var">m2</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> 1.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">induction</span> 1.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">IHle</span>. <span class="id" title="tactic">destruct</span> <span class="id" title="var">n1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">cbn</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">le_S</span>, <span class="id" title="var">le_n</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> (<span class="id" title="var">ack_eq</span> (<span class="id" title="var">S</span> <span class="id" title="var">n1</span>) (<span class="id" title="var">S</span> <span class="id" title="var">m</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">pose</span> (<span class="id" title="var">ack_big</span> <span class="id" title="var">n1</span> (<span class="id" title="var">ack</span> (<span class="id" title="var">S</span> <span class="id" title="var">n1</span>) <span class="id" title="var">m</span>)). <span class="id" title="var">lia</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">induction</span> 1.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">m1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">cbn</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">IHle</span>. <span class="id" title="tactic">do</span> 2 <span class="id" title="tactic">constructor</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> (<span class="id" title="var">ack_eq</span> (<span class="id" title="var">S</span> <span class="id" title="var">m</span>) (<span class="id" title="var">S</span> <span class="id" title="var">m1</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> (<span class="id" title="var">IHle</span> (<span class="id" title="var">S</span> <span class="id" title="var">m1</span>) (<span class="id" title="var">ack</span> (<span class="id" title="var">S</span> <span class="id" title="var">m</span>) <span class="id" title="var">m1</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">ack_big</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> (<span class="id" title="var">ack_eq</span> (<span class="id" title="var">S</span> <span class="id" title="var">m</span>)). <span class="id" title="tactic">apply</span> <span class="id" title="var">IHle</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">le_trans</span> <span class="id" title="keyword">with</span> (<span class="id" title="var">S</span> <span class="id" title="var">m0</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">le_S</span>. <span class="id" title="tactic">exact</span> <span class="id" title="var">H0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">ack_big</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab247"></a><h4 class="section">Ćwiczenie</h4>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <span class="id" title="var">Arith</span>.<br/>

<br/>
</div>

<div class="doc">
Zdefiniuj funkcję <span class="inlinecode"><span class="id" title="var">merge</span></span> o typie
    <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode">(<span class="id" title="var">A</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Type</span>)</span> <span class="inlinecode">(<span class="id" title="var">cmp</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bool</span>),</span> <span class="inlinecode"><span class="id" title="var">list</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">list</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">list</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span>,
    która scala dwie listy posortowane według porządku wyznaczanego przez
    <span class="inlinecode"><span class="id" title="var">cmp</span></span> w jedną posortowaną listę. Jeżeli któraś z list posortowana nie
    jest, wynik może być dowolny.

<div class="paragraph"> </div>

    Wskazówka: dlaczego niby to ćwiczenie pojawia się w podrozdziale o
    rekursji zagnieżdżonej? 
</div>
<div class="code">

<br/>

<br/>
<span class="id" title="keyword">Compute</span> <span class="id" title="var">merge</span> <span class="id" title="var">leb</span> [1; 4; 6; 9] [2; 3; 5; 8].<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;=&nbsp;<span class="inlinecode">[1;</span> <span class="inlinecode">2;</span> <span class="inlinecode">3;</span> <span class="inlinecode">4;</span> <span class="inlinecode">5;</span> <span class="inlinecode">6;</span> <span class="inlinecode">8;</span> <span class="inlinecode">9]</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;list&nbsp;nat&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Obie listy są posortowane według <span class="inlinecode"><span class="id" title="var">leb</span></span>, więc wynik też jest. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Compute</span> <span class="id" title="var">merge</span> <span class="id" title="var">leb</span> [5; 3; 1] [4; 9].<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;=&nbsp;<span class="inlinecode">[4;</span> <span class="inlinecode">5;</span> <span class="inlinecode">3;</span> <span class="inlinecode">1;</span> <span class="inlinecode">9]</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;list&nbsp;nat&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Pierwsza lista nie jest posortowana według <span class="inlinecode"><span class="id" title="var">leb</span></span>, więc wynik jest
    z dupy. 
<div class="paragraph"> </div>

<a name="lab248"></a><h4 class="section">Ćwiczenie</h4>

<div class="paragraph"> </div>

 Skoro już udało ci się zdefiniować <span class="inlinecode"><span class="id" title="var">merge</span></span>, to udowodnij jeszcze parę
    lematów, cobyś nie miał za dużo wolnego czasu. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">merge_eq</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} {<span class="id" title="var">cmp</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">A</span> -&gt; <span class="id" title="var">bool</span>} {<span class="id" title="var">l1</span> <span class="id" title="var">l2</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span>},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">merge</span> <span class="id" title="var">cmp</span> <span class="id" title="var">l1</span> <span class="id" title="var">l2</span> =<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">l1</span>, <span class="id" title="var">l2</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| [], <span class="id" title="var">_</span> =&gt; <span class="id" title="var">l2</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">_</span>, [] =&gt; <span class="id" title="var">l1</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">h1</span> :: <span class="id" title="var">t1</span>, <span class="id" title="var">h2</span> :: <span class="id" title="var">t2</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">if</span> <span class="id" title="var">cmp</span> <span class="id" title="var">h1</span> <span class="id" title="var">h2</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">then</span> <span class="id" title="var">h1</span> :: <span class="id" title="var">merge</span> <span class="id" title="var">cmp</span> <span class="id" title="var">t1</span> <span class="id" title="var">l2</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">else</span> <span class="id" title="var">h2</span> :: <span class="id" title="var">merge</span> <span class="id" title="var">cmp</span> <span class="id" title="var">l1</span> <span class="id" title="var">t2</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">merge_nil_l</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} {<span class="id" title="var">cmp</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">A</span> -&gt; <span class="id" title="var">bool</span>} {<span class="id" title="var">l</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span>},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">merge</span> <span class="id" title="var">cmp</span> [] <span class="id" title="var">l</span> = <span class="id" title="var">l</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">merge_nil_r</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} {<span class="id" title="var">cmp</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">A</span> -&gt; <span class="id" title="var">bool</span>} {<span class="id" title="var">l</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span>},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">merge</span> <span class="id" title="var">cmp</span> <span class="id" title="var">l</span> [] = <span class="id" title="var">l</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">l</span>; <span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">Permutation_merge</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} {<span class="id" title="var">f</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">A</span> -&gt; <span class="id" title="var">bool</span>} {<span class="id" title="var">l1</span> <span class="id" title="var">l2</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span>},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">Permutation</span> (<span class="id" title="var">merge</span> <span class="id" title="var">f</span> <span class="id" title="var">l1</span> <span class="id" title="var">l2</span>) (<span class="id" title="var">l1</span> ++ <span class="id" title="var">l2</span>).<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">merge_length</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} {<span class="id" title="var">f</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">A</span> -&gt; <span class="id" title="var">bool</span>} {<span class="id" title="var">l1</span> <span class="id" title="var">l2</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span>},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">length</span> (<span class="id" title="var">merge</span> <span class="id" title="var">f</span> <span class="id" title="var">l1</span> <span class="id" title="var">l2</span>) = <span class="id" title="var">length</span> <span class="id" title="var">l1</span> + <span class="id" title="var">length</span> <span class="id" title="var">l2</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">merge_map</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> {<span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>} {<span class="id" title="var">cmp</span> : <span class="id" title="var">B</span> -&gt; <span class="id" title="var">B</span> -&gt; <span class="id" title="var">bool</span>} {<span class="id" title="var">f</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">B</span>} {<span class="id" title="var">l1</span> <span class="id" title="var">l2</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span>},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">merge</span> <span class="id" title="var">cmp</span> (<span class="id" title="var">map</span> <span class="id" title="var">f</span> <span class="id" title="var">l1</span>) (<span class="id" title="var">map</span> <span class="id" title="var">f</span> <span class="id" title="var">l2</span>) =<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">map</span> <span class="id" title="var">f</span> (<span class="id" title="var">merge</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> : <span class="id" title="var">A</span> =&gt; <span class="id" title="var">cmp</span> (<span class="id" title="var">f</span> <span class="id" title="var">x</span>) (<span class="id" title="var">f</span> <span class="id" title="var">y</span>)) <span class="id" title="var">l1</span> <span class="id" title="var">l2</span>).<br/>

<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">merge_replicate</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} {<span class="id" title="var">cmp</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">A</span> -&gt; <span class="id" title="var">bool</span>} {<span class="id" title="var">x</span> <span class="id" title="var">y</span> : <span class="id" title="var">A</span>} {<span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">merge</span> <span class="id" title="var">cmp</span> (<span class="id" title="var">replicate</span> <span class="id" title="var">n</span> <span class="id" title="var">x</span>) (<span class="id" title="var">replicate</span> <span class="id" title="var">m</span> <span class="id" title="var">y</span>) =<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">if</span> <span class="id" title="var">cmp</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">then</span> <span class="id" title="var">replicate</span> <span class="id" title="var">n</span> <span class="id" title="var">x</span> ++ <span class="id" title="var">replicate</span> <span class="id" title="var">m</span> <span class="id" title="var">y</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">else</span> <span class="id" title="var">replicate</span> <span class="id" title="var">m</span> <span class="id" title="var">y</span> ++ <span class="id" title="var">replicate</span> <span class="id" title="var">n</span> <span class="id" title="var">x</span>.<br/>

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">ins</span><br/>
&nbsp;&nbsp;{<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">cmp</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">A</span> -&gt; <span class="id" title="var">bool</span>) (<span class="id" title="var">x</span> : <span class="id" title="var">A</span>) (<span class="id" title="var">l</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span>) : <span class="id" title="var">list</span> <span class="id" title="var">A</span> :=<br/>
<span class="id" title="keyword">match</span> <span class="id" title="var">l</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| [] =&gt; [<span class="id" title="var">x</span>]<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">h</span> :: <span class="id" title="var">t</span> =&gt; <span class="id" title="keyword">if</span> <span class="id" title="var">cmp</span> <span class="id" title="var">x</span> <span class="id" title="var">h</span> <span class="id" title="keyword">then</span> <span class="id" title="var">x</span> :: <span class="id" title="var">h</span> :: <span class="id" title="var">t</span> <span class="id" title="keyword">else</span> <span class="id" title="var">h</span> :: <span class="id" title="var">ins</span> <span class="id" title="var">cmp</span> <span class="id" title="var">x</span> <span class="id" title="var">t</span><br/>
<span class="id" title="keyword">end</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">merge_ins_l</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} {<span class="id" title="var">cmp</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">A</span> -&gt; <span class="id" title="var">bool</span>} {<span class="id" title="var">l</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span>} {<span class="id" title="var">x</span> : <span class="id" title="var">A</span>},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">merge</span> <span class="id" title="var">cmp</span> [<span class="id" title="var">x</span>] <span class="id" title="var">l</span> = <span class="id" title="var">ins</span> <span class="id" title="var">cmp</span> <span class="id" title="var">x</span> <span class="id" title="var">l</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">merge_ins_r</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} {<span class="id" title="var">cmp</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">A</span> -&gt; <span class="id" title="var">bool</span>} {<span class="id" title="var">l</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span>} {<span class="id" title="var">x</span> : <span class="id" title="var">A</span>},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">merge</span> <span class="id" title="var">cmp</span> <span class="id" title="var">l</span> [<span class="id" title="var">x</span>] = <span class="id" title="var">ins</span> <span class="id" title="var">cmp</span> <span class="id" title="var">x</span> <span class="id" title="var">l</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">merge_ins'</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} {<span class="id" title="var">cmp</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">A</span> -&gt; <span class="id" title="var">bool</span>} {<span class="id" title="var">l1</span> <span class="id" title="var">l2</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span>} {<span class="id" title="var">x</span> : <span class="id" title="var">A</span>},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">merge</span> <span class="id" title="var">cmp</span> (<span class="id" title="var">ins</span> <span class="id" title="var">cmp</span> <span class="id" title="var">x</span> <span class="id" title="var">l1</span>) (<span class="id" title="var">ins</span> <span class="id" title="var">cmp</span> <span class="id" title="var">x</span> <span class="id" title="var">l2</span>) =<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">ins</span> <span class="id" title="var">cmp</span> <span class="id" title="var">x</span> (<span class="id" title="var">ins</span> <span class="id" title="var">cmp</span> <span class="id" title="var">x</span> (<span class="id" title="var">merge</span> <span class="id" title="var">cmp</span> <span class="id" title="var">l1</span> <span class="id" title="var">l2</span>)).<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">merge_all_true</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} {<span class="id" title="var">cmp</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">A</span> -&gt; <span class="id" title="var">bool</span>} {<span class="id" title="var">l</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span>} {<span class="id" title="var">x</span> : <span class="id" title="var">A</span>},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">all</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">y</span> : <span class="id" title="var">A</span> =&gt; <span class="id" title="var">cmp</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span>) <span class="id" title="var">l</span> = <span class="id" title="var">true</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">merge</span> <span class="id" title="var">cmp</span> [<span class="id" title="var">x</span>] <span class="id" title="var">l</span> = <span class="id" title="var">x</span> :: <span class="id" title="var">l</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">merge_ind</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">P</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span> -&gt; <span class="id" title="var">list</span> <span class="id" title="var">A</span> -&gt; <span class="id" title="var">list</span> <span class="id" title="var">A</span> -&gt; <span class="id" title="keyword">Prop</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id" title="var">f</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">A</span> -&gt; <span class="id" title="var">bool</span>},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">forall</span> <span class="id" title="var">l</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span>, <span class="id" title="var">P</span> [] <span class="id" title="var">l</span> <span class="id" title="var">l</span>) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">forall</span> <span class="id" title="var">l</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span>, <span class="id" title="var">P</span> <span class="id" title="var">l</span> [] <span class="id" title="var">l</span>) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">forall</span> (<span class="id" title="var">h1</span> <span class="id" title="var">h2</span> : <span class="id" title="var">A</span>) (<span class="id" title="var">t1</span> <span class="id" title="var">t2</span> <span class="id" title="var">r</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">f</span> <span class="id" title="var">h1</span> <span class="id" title="var">h2</span> = <span class="id" title="var">true</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">P</span> <span class="id" title="var">t1</span> (<span class="id" title="var">h2</span> :: <span class="id" title="var">t2</span>) <span class="id" title="var">r</span> -&gt; <span class="id" title="var">P</span> (<span class="id" title="var">h1</span> :: <span class="id" title="var">t1</span>) (<span class="id" title="var">h2</span> :: <span class="id" title="var">t2</span>) (<span class="id" title="var">h1</span> :: <span class="id" title="var">r</span>)) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">forall</span> (<span class="id" title="var">h1</span> <span class="id" title="var">h2</span> : <span class="id" title="var">A</span>) (<span class="id" title="var">t1</span> <span class="id" title="var">t2</span> <span class="id" title="var">r</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">f</span> <span class="id" title="var">h1</span> <span class="id" title="var">h2</span> = <span class="id" title="var">false</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">P</span> (<span class="id" title="var">h1</span> :: <span class="id" title="var">t1</span>) <span class="id" title="var">t2</span> <span class="id" title="var">r</span> -&gt; <span class="id" title="var">P</span> (<span class="id" title="var">h1</span> :: <span class="id" title="var">t1</span>) (<span class="id" title="var">h2</span> :: <span class="id" title="var">t2</span>) (<span class="id" title="var">h2</span> :: <span class="id" title="var">r</span>)) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">l1</span> <span class="id" title="var">l2</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span>, <span class="id" title="var">P</span> <span class="id" title="var">l1</span> <span class="id" title="var">l2</span> (<span class="id" title="var">merge</span> <span class="id" title="var">f</span> <span class="id" title="var">l1</span> <span class="id" title="var">l2</span>).<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">merge_filter</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} {<span class="id" title="var">cmp</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">A</span> -&gt; <span class="id" title="var">bool</span>} {<span class="id" title="var">p</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">bool</span>} {<span class="id" title="var">l1</span> <span class="id" title="var">l2</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span>},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">merge</span> <span class="id" title="var">cmp</span> (<span class="id" title="var">filter</span> <span class="id" title="var">p</span> <span class="id" title="var">l1</span>) (<span class="id" title="var">filter</span> <span class="id" title="var">p</span> <span class="id" title="var">l2</span>) =<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">filter</span> <span class="id" title="var">p</span> (<span class="id" title="var">merge</span> <span class="id" title="var">cmp</span> <span class="id" title="var">l1</span> <span class="id" title="var">l2</span>).<br/>

<br/>
</div>

<div class="doc">
<a name="lab249"></a><h1 class="section">Rząd rżnie głupa, czyli o pierwszym i wyższym rzędzie (TODO)</h1>

<div class="paragraph"> </div>

<a name="lab250"></a><h1 class="section">Rekursja wyższego rzędu (TODO)</h1>

<div class="paragraph"> </div>

 Pozostaje kwestia rekursji wyższego rzędu. Co to takiego? Ano dotychczas
    wszystkie nasze wywołania rekurencyjne były konkretne, czyli zaaplikowane
    do argumentów.

<div class="paragraph"> </div>

    Mogłoby się wydawać, że jest to jedyny możliwy sposób robienia wywołań
    rekurencyjnych, jednak nie jest tak. Wywołania rekurencyjne mogą mieć
    również inną, wyższorzędową postać, a mianowicie - możemy przekazać
    funkcję, którą właśnie definiujemy, jako argument do innej funkcji.

<div class="paragraph"> </div>

    Dlaczego jest to wywołanie rekurencyjne, skoro nie wywołujemy naszej
    funkcji? Ano dlatego, że tamta funkcja, która dostaje naszą jako
    argument, dostaje niejako możliwość robienia wywołań rekurencyjnych.
    W zależności od tego, co robi ta funkcja, wszystko może być ok (np.
    gdy ignoruje ona naszą funkcję i w ogóle jej nie używa) lub śmiertelnie
    niebezpieczne (gdy próbuje zrobić wywołanie rekurencyjne na strukturalnie
    większym argumencie).

<div class="paragraph"> </div>

    Sztoby za dużo nie godoć, bajszpil: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">Tree</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Node</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">list</span> (<span class="id" title="var">Tree</span> <span class="id" title="var">A</span>) -&gt; <span class="id" title="var">Tree</span> <span class="id" title="var">A</span>.<br/>

<br/>
<span class="id" title="var">Arguments</span> <span class="id" title="var">Node</span> {<span class="id" title="var">A</span>} <span class="id" title="var">_</span> <span class="id" title="var">_</span>.<br/>

<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" title="var">Tree</span></span> to typ drzew niepustych, które mogą mieć dowolną (ale skończoną)
    ilość poddrzew. Spróbujmy zdefiniować funkcję, która zwraca lustrzane
    odbicie drzewa. 
</div>
<div class="code">

<br/>
<span class="comment">(*<br/>
Fixpoint&nbsp;mirror&nbsp;{A&nbsp;:&nbsp;Type}&nbsp;(t&nbsp;:&nbsp;Tree&nbsp;A)&nbsp;:&nbsp;Tree&nbsp;A&nbsp;:=<br/>
match&nbsp;t&nbsp;with<br/>
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Node&nbsp;x&nbsp;ts&nbsp;=&gt;&nbsp;Node&nbsp;x&nbsp;(rev&nbsp;(map&nbsp;mirror&nbsp;ts))<br/>
end.<br/>
*)</span><br/>

<br/>
</div>

<div class="doc">
Nie jest to zbyt trudne. Rekurencyjnie odbijamy wszystkie poddrzewa za
    pomocą <span class="inlinecode"><span class="id" title="var">map</span></span> <span class="inlinecode"><span class="id" title="var">mirror</span></span>, a następnie odwracamy kolejność poddrzew z użyciem
    <span class="inlinecode"><span class="id" title="var">rev</span></span>. Chociaż poszło gładko, to mamy tu do czynienia z czymś, czego
    wcześniej nie widzieliśmy. Nie ma tu żadnego wywołania rekurencyjnego,
    a mimo to funkcja działa ok. Dlaczego? Właśnie dlatego, że wywołania
    rekurencyjne są robione przez funkcję <span class="inlinecode"><span class="id" title="var">map</span></span>. Mamy więc do czynienia z
    rekursją wyższego rzędu. 
</div>
<div class="code">

<br/>
<span class="comment">(*<br/>
Require&nbsp;Import&nbsp;List.<br/>
Import&nbsp;ListNotations.<br/>
Print&nbsp;Forall2.<br/>
<br/>
Inductive&nbsp;mirrorG&nbsp;{A&nbsp;:&nbsp;Type}&nbsp;:&nbsp;Tree&nbsp;A&nbsp;-&gt;&nbsp;Tree&nbsp;A&nbsp;-&gt;&nbsp;Prop&nbsp;:=<br/>
&nbsp;&nbsp;|&nbsp;mirrorG_0&nbsp;:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;forall&nbsp;(x&nbsp;:&nbsp;A)&nbsp;(ts&nbsp;rs&nbsp;:&nbsp;list&nbsp;(Tree&nbsp;A)),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Forall2&nbsp;mirrorG&nbsp;ts&nbsp;rs&nbsp;-&gt;&nbsp;mirrorG&nbsp;(Node&nbsp;x&nbsp;ts)&nbsp;(Node&nbsp;x&nbsp;(rev&nbsp;rs)).<br/>
<br/>
Definition&nbsp;mab&nbsp;{A&nbsp;B&nbsp;:&nbsp;Type}&nbsp;(f&nbsp;:&nbsp;A&nbsp;-&gt;&nbsp;B)&nbsp;:=<br/>
&nbsp;&nbsp;fix&nbsp;mab&nbsp;(l&nbsp;:&nbsp;list&nbsp;A)&nbsp;:&nbsp;list&nbsp;B&nbsp;:=<br/>
&nbsp;&nbsp;match&nbsp;l&nbsp;with<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;<span class="inlinecode"></span>&nbsp;=&gt;&nbsp;<span class="inlinecode"></span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;h&nbsp;::&nbsp;t&nbsp;=&gt;&nbsp;f&nbsp;h&nbsp;::&nbsp;mab&nbsp;t<br/>
&nbsp;&nbsp;end.<br/>
<br/>
Inductive&nbsp;mirrorFG<br/>
&nbsp;&nbsp;{A&nbsp;:&nbsp;Type}&nbsp;(f&nbsp;:&nbsp;Tree&nbsp;A&nbsp;-&gt;&nbsp;Tree&nbsp;A)&nbsp;:&nbsp;Tree&nbsp;A&nbsp;-&gt;&nbsp;Tree&nbsp;A&nbsp;-&gt;&nbsp;Prop&nbsp;:=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;mirrorFG_0&nbsp;:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;forall&nbsp;(x&nbsp;:&nbsp;A)&nbsp;(ts&nbsp;:&nbsp;list&nbsp;(Tree&nbsp;A)),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mirrorG&nbsp;(Node&nbsp;x&nbsp;ts)&nbsp;(Node&nbsp;x&nbsp;(rev&nbsp;(map&nbsp;f&nbsp;ts))).<br/>
*)</span><br/>

<br/>
</div>

<div class="doc">
Inny przykład: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">Tree'</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Node'</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="keyword">forall</span> {<span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>}, (<span class="id" title="var">B</span> -&gt; <span class="id" title="var">Tree'</span> <span class="id" title="var">A</span>) -&gt; <span class="id" title="var">Tree'</span> <span class="id" title="var">A</span>.<br/>

<br/>
<span class="id" title="var">Arguments</span> <span class="id" title="var">Node'</span> {<span class="id" title="var">A</span>} <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>.<br/>

<br/>
</div>

<div class="doc">
Tym razem mamy drzewo, które może mieć naprawdę dowolną ilość poddrzew,
    ale jego poddrzewa są nieuporządkowane. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">mirror'</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">t</span> : <span class="id" title="var">Tree'</span> <span class="id" title="var">A</span>) : <span class="id" title="var">Tree'</span> <span class="id" title="var">A</span> :=<br/>
<span class="id" title="keyword">match</span> <span class="id" title="var">t</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Node'</span> <span class="id" title="var">x</span> <span class="id" title="var">B</span> <span class="id" title="var">ts</span> =&gt; <span class="id" title="var">Node'</span> <span class="id" title="var">x</span> <span class="id" title="var">B</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">b</span> : <span class="id" title="var">B</span> =&gt; <span class="id" title="var">mirror'</span> (<span class="id" title="var">ts</span> <span class="id" title="var">b</span>))<br/>
<span class="id" title="keyword">end</span>.<br/>
</div>
