- listy
- dokończyć rozdział o funkcjach (więcej ukrytej teorii kategorii)
- dokończyć rozdział o relacjach
- opisać foldy dla list
- Logika:
  - różne alternatywne definicje równości (np. JMeq, eq_dep)
  - aksjomaty
- Rekursja:
  - rekursja strukturalna
  - rekursja ogonowa
  - rekursja polimorficzna
  - rekursja "monotoniczna" (fix w fiksie)
  - rekursja "po paliwie"
  - rekursja dobrze ufundowana
  - Bove-Capretta
  - rekursja przez iterację
- Indukcja:
  - foldy
  - reguły dla indukcji dobrze ufundowanej
- Typy:
  - opisać lepiej produkt zależny
  - dodać podrozdział o zależnych typach induktywnych
  - dodać podrozdział o typach induktywnych z nieskończoną ilością argumentów rekurencyjnych (A -> T)
  - o silnych specyfikacjach
- R ileś tam: Matematyka
  - setoidy
  - teoria porządków
  - monoidy/teoria grup
- R ileś tam + 1: przegląd Haskellowego podwórka. Jeżeli nie możesz się doczekać, patrz [tu](https://github.com/Zeimer/HSLib)
- R6: Teoria Kategorii — ho ho, pieśń przyszłości! Achtung: przemycać tego jak najwięcej.
- Zadania TODO:
  - Zrób zadania z definiowania induktywnych typów i predykatów
- Inne:
  - definiowanie przez dowód
- Sugestie:
  - być może przesunąć Empty_set i unit za Enumeracje, a prod i sum za Właściwości konstruktorów. Wcisnąć tu ukrytą teorię kategorii.

(** Sugestie i problemy z koła:
    - nie trzeba specjalizować hipotezy, żeby przepisać
    - być może coś więcej o równości (i jej alternatywnej definicji?)
    - napisać bardziej wprost o deklarowaniu hipotez
    - ulepszyć ściągę z taktykami i komendami
    - potrzeba więcej o rozstrzygalnej równości
*)

(** Najnowsze TODO:
    - Dodać przykładowe wywołania funkcji do ćwiczeń.
    - Wydzielić z R2 nowy rozdział o rekordach, klasach i połączyć to z
      rozstrzygalnością oraz typem [reflect]
    - Przemieścić z R2 podrozdziały o sortach i o hierarchii uniwersów.
      Najlepiej gdzieś na sam koniec
    - Przemieścić z R1 podrozdziały "Typy i termy" oraz "Typy a zbiory".
    - Dodać podrozdział o typach skończonych.
    - Napisać coś o kodowaniu Churcha.
    - Napisać coś o rekursji ogonowej i opisać poświęcone jej techniki
      dowodzenia.
    - Rozbudować opis równości i konwertowalności o dokładne opisy ewaluacji
      i taktyk typu cbn/cbv etc.
    - Opisać relacje prefix/infix/suffix/interfix dla list jako jakotakie
      ćwiczenie
    - Sześć sposobów na ogólną rekursję w Coqu:
      - rekursja dobrze ufundowana
      - rekursja po paliwie
      - rekursja wydmuszkowa (Coq'Art)
      - teoria dziedzin (computation, CPDT)
      - comp (CPDT)
      - koindukcja (thunk, CPDT)
      - Bove-Capretta z trickiem wycinającym indukcję-rekursję
*)

(** TODO:
    - ogólnie trzeba będzie zrobić gruntowny refaktoring list według
      planu zawartego w List_sig.v
    - niedokończone funkcje (do niedawna oznaczone jako TODO):
      - isZero (przenieść do rozdziału o arytmetyce)
      - isEmpty
      - snoc
      - bind
      - iterate i iter (join, bind)
      - insert (join, bind, iterate, init)
      - remove
      - take (join, bind, last_take, take_remove),
      - drop (join, bind, remove)
      - iterate (od removeFirst wzwyż)
      - removeFirst (removeFirst_zip)
      - findIndex (init, tail)
      - filter (tail, init)
      - findIndices (join, bind, takeWhile, dropWhile)
      - pmap (iterate, nth, last, tail i init, take i drop, takedrop, zip,
          unzip, zipWith, unzipWith, removeFirst i removeLast, findIndex,
          findIndices)
      - intersperse (init, insert, remove, drop, zip, zipWith, unzip)
      - groupBy
      - Rep (join, nth)
      - AtLeast (nth, head, last, init, tail)
      - Exactly (join, nth, head, tail, init, last, zip)
      - AtMost
    - napisać wstępy do poszczególnych funkcji
*)

(** Ogólne plany na rozdziały X:
    - typ [bool] (powinien być osobny rozdział). Inne:
      - boolowska logika ternarna, być może jako tour de force dla
        automatyzacji? albo test kreatywności
    - typ [option] (być może przy okazji funktory?)
    - wcisnąć tu rozdział o produktach, sumach i funkcjach?
    - arytmetyka i typ [nat]. Reszta arytmetyki:
      - liczby dodatnie (positive)
      - binarne liczby naturalne
      - liczby całkowite
      - liczby wymierne
      - systemy liczbowe
    - listy [list] i ich różne pochodne:
      - listy niepuste [nel]
      - wektory zależne [vec]
      - wektory podtypowe (jak w ssreflekcie)
    - drzewa ukorzenione:
      - binarne węzłowe [BTree]
      - binarne liściowe (wisienki)
      - ogólne węzłowe [Tree]
      - ogólne liściowe [RoseTree]
      - jakieś inne? (węzłowe niepuste)
    - algorytmy
      - drzewa wyszukiwań
      - sterty
      - sortowanie
*)

(** TODO dla R1:
    - zrefaktoryzować rozdział:
      - opisać najpierw logikę konstruktywną, a potem klasyczną
      - przedstawić obie jako użyteczne
      - na końcu każdego z opisów dać paradoksy, żeby zobrazować
        różnice między językiem naturalnym i matematycznym
    - przejrzeć zadania:
      - wyrzucić zadania mącące (mieszające typy i zdania)
      - dodać zadanie dotyczące czytania twierdzeń i dowodów
      - dodać zadania dotyczące czytania formuł (precedencja etc.)
    - dokończyć ściągę i dać na koniec
    - być może podzielić rozdział na kilka
    - potencjalnie pozbyć się sekcji
    - dodać jakieś wyjaśnienia do ćwiczeń
    - więcej zadań z exists
    - zadania z klasycznego rachunku kwantyfikatorów
    - napisać coś o nazwach zmiennych związanych
*)

(** TODO dla X3:
    - dokończ [isEmpty]
    - opisz niestandardowe reguły indukcyjne dla list (najlepiej przed
      przed funkcją [intersperse]).
    - przenieś [intersperse] na sam koniec funkcji i dorzuć jeszcze
      kilka dziwnych (z niestandardowym kształtem indukcji)
    - opisz zwijanie i rozwijanie ([fold] i [foldl])
    - opisz sumy prefiksowe ([scanr] i [scanl])
    - popracować nad [findIndices] (i to w dwóch wersjach - być może
      jest to dobry pretekst dla wprowadzenia stylu programowania z
      akumulatorem?)
    - ogarnij osobny rozdział z zadaniami dla [option].
      Stąd zadania dla [head], [last], [tail] i [init]
    - zrób osobno: funkcje na listach dla typów mających jakieś
      specjalne rzeczy (np. rozstrzygalną równość)
    - [AtMost]
*)

(** TODO dla R4:
    - nieopisane taktyki: [induction], [inversion], [destruct]
    - przerobić "drobne taktyki" na "taktyki do zarządzania kontekstem"
    - przenieść opis taktyki [pattern] (i odpowiadające zadanie) do
      części o taktykach dla redukcji
*)
